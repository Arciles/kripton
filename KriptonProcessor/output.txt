[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Kripton Annotation Processor Library 1.5.1-SNAPSHOT-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ kripton-processor ---
[INFO] Deleting C:\Users\xcesco\git\kripton\KriptonProcessor\target
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ kripton-processor ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.6.0:compile (default-compile) @ kripton-processor ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 197 source files to C:\Users\xcesco\git\kripton\KriptonProcessor\target\classes
[WARNING] /C:/Users/xcesco/git/kripton/KriptonProcessor/src/main/java/com/abubusoft/kripton/processor/core/ModelProperty.java:[213,30] unchecked call to visit(P) as a member of the raw type com.abubusoft.kripton.processor.core.ModelElementVisitor
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ kripton-processor ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 0 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.6.0:testCompile (default-testCompile) @ kripton-processor ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 515 source files to C:\Users\xcesco\git\kripton\KriptonProcessor\target\test-classes
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ kripton-processor ---
[INFO] Surefire report directory: C:\Users\xcesco\git\kripton\KriptonProcessor\target\surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running bind.kripton42faster.Test42CompileSuite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.726 sec
Running bind.kripton42faster.TestCompile42
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.425 sec
Running bind.kripton70.Test70CompileSuite
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.51 sec
Running bind.kripton70.TestCompile70A
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.34 sec
Running bind.kripton70.TestCompile70All
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.599 sec
Running bind.kripton71List.Test71CompileSuite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.616 sec
Running bind.kripton71List.TestCompile71
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.581 sec
Running bind.kripton72.Test72CompileSuite
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.195 sec
Running bind.kripton72.TestCompile72
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.329 sec
Running bind.kripton72.TestCompile72A
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.325 sec
Running bind.kripton73Array.Test73CompileSuite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.416 sec
Running bind.kripton73Array.TestCompile73
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.329 sec
Running bind.kripton74Map.Test74CompileSuite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.284 sec
Running bind.kripton74Map.TestCompile74
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.255 sec
Running bind.kripton75ByteArray.Test75CompileSuite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.198 sec
Running bind.kripton75ByteArray.TestCompile75
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.247 sec
Running bind.kripton76Errors.Test76Attribute
Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.471 sec
Running bind.kripton76Errors.Test76CompileSuite
Tests run: 10, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.857 sec
Running bind.kripton76Errors.Test76Value
Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.375 sec
Running bind.kripton77.Test77
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.008 sec
Running bind.kripton78.Test78CompileSuite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.192 sec
Running bind.kripton78.TestCompile78
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.182 sec
Running bind.kripton80ContextCollection.Test80ACompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.163 sec
Running bind.kripton80ContextCollection.Test80ALLCompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.213 sec
Running bind.kripton80ContextCollection.Test80CompileSuite
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.494 sec
Running bind.kripton81MoreCoverageTests.Test81ACompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.166 sec
Running bind.kripton81MoreCoverageTests.Test81BCompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.161 sec
Running bind.kripton81MoreCoverageTests.Test81CCompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.137 sec
Running bind.kripton81MoreCoverageTests.Test81CompileSuite
Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.884 sec
Running bind.kripton81MoreCoverageTests.Test81GHILMNOPCompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.323 sec
Running bind.kripton81MoreCoverageTests.Test81VCompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.201 sec
Running bind.kripton87TypeAdapter.Test87ACompile
Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.336 sec
Running bind.kripton87TypeAdapter.Test87CompileSuite
Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.997 sec
Running com.abubusoft.kripton.processor.bind.transform.Test81DCompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 sec
Running com.abubusoft.kripton.processor.sharedprefs.transform.Test81ECompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 sec
Running com.abubusoft.kripton.processor.sqlite.transform.Test81FCompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 sec
Running commons.benchmark.TestBenchmarkCompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.238 sec
Running commons.benchmark.TestBenchmarkCompileSuite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.203 sec
Running commons.kripton86.Test86CompileSuite
Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.862 sec
Running commons.kripton86.TestBindCompile86
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.412 sec
Running commons.kripton86.TestSqliteCompile86
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.365 sec
Running shared.kripton45.Test45Compile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.182 sec
Running shared.kripton45.Test45Suite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.184 sec
Running shared.kripton46.Test46Compile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.228 sec
Running shared.kripton47.Test47Compile
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.435 sec
Running shared.kripton47.Test47Suite
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.417 sec
Running shared.kripton50.TestKripton50
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.179 sec
Running sqlite.example01.Example01Test
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.393 sec
Running sqlite.foreignKey.TestForeignKeyCompile
Tests run: 3, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.374 sec <<< FAILURE!
testForeignKeyCompile1(sqlite.foreignKey.TestForeignKeyCompile)  Time elapsed: 0.136 sec  <<< FAILURE!
java.lang.AssertionError: Compilation produced the following errors:

error: com.abubusoft.kripton.processor.exceptions.CircularRelationshipException: Table definition bean_a_2 is in a circular dependency


Generated Files
===============

/SOURCE_OUTPUT/sqlite/foreignKey/BindDummyAsyncTask.java:
package sqlite.foreignKey;

import android.os.AsyncTask;
import java.lang.Override;
import java.lang.SuppressWarnings;

/**
 *
 * <p>
 * Specialized async task to make async database operation on activity
 * </p>
 *
 * <p>
 * Unlike standard async task, for an instance of this class can be used many time.
 * </p>
 *
 * <p>
 * When method <code>execute</code> is invoked, an inner async task is created.
 * </p>
 *
 * @see BindDummyDaoFactory
 * @see BindDummyDataSource
 */
public abstract class BindDummyAsyncTask<I, U, R> {
  /**
   * If <code>true</code> indicates database operations are only read operations
   *
   */
  protected boolean readOnlyTask;

  /**
   * Async task wrapped by this class
   *
   */
  protected AsyncTask<I, U, R> asyncTask;

  /**
   * <p>
   * With this constructor, a read only database connection will be used
   * </p>
   */
  public BindDummyAsyncTask() {
    this(true);}

  /**
   * <p>
   * With this constructor it is possible to specify which type of database use in async task
   * </p>
   *
   * @param readOnlyTask if true, force async task to use read only database connection
   */
  public BindDummyAsyncTask(boolean readOnlyTask) {
    this.readOnlyTask = readOnlyTask;}

  /**
   * Use this method for operations on UI-thread before start execution
   */
  public void onPreExecute() {
  }

  /**
   * Method used to encapsulate operations on datasource
   *
   * @param daoFactory
   * 	dao factory. Use it to retrieve DAO
   * @return
   * 	result of operation (list, bean, etc)
   */
  public abstract R onExecute(BindDummyDaoFactory daoFactory);

  /**
   * Use this method for operations on UI-thread after execution
   */
  public abstract void onFinish(R result);

  /**
   * Override this method to display operation progress on UI-Thread
   */
  public void onProgressUpdate(U... update) {
  }

  /**
   * Method to start operations.
   *
   * @param
   * 	data input
   */
  public void execute(@SuppressWarnings("unchecked") I... params) {
    asyncTask=new AsyncTask<I, U, R>() {
      @Override
      public void onPreExecute() {
        BindDummyAsyncTask.this.onPreExecute();
      }

      @Override
      public R doInBackground(@SuppressWarnings("unchecked") I... params) {
        BindDummyDataSource dataSource=BindDummyDataSource.instance();
        R result=null;
        if (readOnlyTask) dataSource.openReadOnlyDatabase(); else dataSource.openWritableDatabase();
        try {
          result=onExecute(dataSource);
        } catch(Exception e) {
        } finally {
          if (dataSource.isOpen()) {
            dataSource.close();
          }
        }
        return result;
      }

      @Override
      public void onProgressUpdate(@SuppressWarnings("unchecked") U... values) {
        BindDummyAsyncTask.this.onProgressUpdate(values);
      }

      @Override
      public void onPostExecute(R result) {
        BindDummyAsyncTask.this.onFinish(result);
      }
    };
    asyncTask.execute(params);
  }

  /**
   * Simple implementation of async task. It uses read only database.
   *
   * @see BindDummyDaoFactory
   * @see BindDummyDataSource
   */
  public abstract static class Simple<R> extends BindDummyAsyncTask<Void, Void, R> {
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_2Table.java:
package sqlite.foreignKey;

import java.lang.String;

/**
 * <p>
 * Entity <code>BeanA_2</code> is associated to table <code>bean_a_2</code>
 * This class represents table associated to entity.
 * </p>
 *  @see BeanA_2
 */
public class BeanA_2Table {
  /**
   * Costant represents name of table bean_a_2
   */
  public static final String TABLE_NAME = "bean_a_2";

  /**
   * <p>
   * DDL to create table bean_a_2
   * </p>
   *
   * <pre>CREATE TABLE bean_a_2 (pk INTEGER PRIMARY KEY AUTOINCREMENT, value_string2 TEXT);</pre>
   */
  public static final String CREATE_TABLE_SQL = "CREATE TABLE bean_a_2 (pk INTEGER PRIMARY KEY AUTOINCREMENT, value_string2 TEXT);";

  /**
   * <p>
   * DDL to drop table bean_a_2
   * </p>
   *
   * <pre>DROP TABLE IF EXISTS bean_a_2;</pre>
   */
  public static final String DROP_TABLE_SQL = "DROP TABLE IF EXISTS bean_a_2;";

  /**
   * Entity's property <code>id</code> is associated to table column <code>pk</code>. This costant represents column name.
   *
   *  @see BeanA_2#id
   */
  public static final String COLUMN_ID = "pk";

  /**
   * Entity's property <code>valueString2</code> is associated to table column <code>value_string2</code>. This costant represents column name.
   *
   *  @see BeanA_2#valueString2
   */
  public static final String COLUMN_VALUE_STRING2 = "value_string2";
}


/SOURCE_OUTPUT/sqlite/foreignKey/DaoBeanA_1Impl.java:
package sqlite.foreignKey;

import android.content.ContentValues;
import android.database.Cursor;
import com.abubusoft.kripton.android.Logger;
import com.abubusoft.kripton.android.sqlite.AbstractDao;
import com.abubusoft.kripton.common.StringUtils;
import java.util.LinkedList;
import java.util.List;

/**
 * <p>
 * DAO implementation for entity <code>BeanA_1</code>, based on interface <code>DaoBeanA_1</code>
 * </p>
 *
 *  @see BeanA_1
 *  @see DaoBeanA_1
 *  @see BeanA_1Table
 */
public class DaoBeanA_1Impl extends AbstractDao implements DaoBeanA_1 {
  public DaoBeanA_1Impl(BindDummyDataSource dataSet) {
    super(dataSet);
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE 1=1</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>bean_a2_id</dt><dd>is associated to bean's property <strong>beanA2Id</strong></dd>
   * 	<dt>value_string</dt><dd>is associated to bean's property <strong>valueString</strong></dd>
   * </dl>
   *
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_1> selectAll() {
    // build where condition
    String[] args={};

    Logger.info(StringUtils.formatSQL("SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE 1=1"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE 1=1", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_1> resultList=new LinkedList<BeanA_1>();
    BeanA_1 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("bean_a2_id");
      int index2=cursor.getColumnIndex("value_string");

      do
       {
        resultBean=new BeanA_1();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1); }
        if (!cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE id=${id}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>bean_a2_id</dt><dd>is associated to bean's property <strong>beanA2Id</strong></dd>
   * 	<dt>value_string</dt><dd>is associated to bean's property <strong>valueString</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${id}</dt><dd>is binded to method's parameter <strong>id</strong></dd>
   * </dl>
   *
   * @param id
   * 	is binded to ${id}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_1> selectById(long id) {
    // build where condition
    String[] args={String.valueOf(id)};

    Logger.info(StringUtils.formatSQL("SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE id='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE id=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_1> resultList=new LinkedList<BeanA_1>();
    BeanA_1 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("bean_a2_id");
      int index2=cursor.getColumnIndex("value_string");

      do
       {
        resultBean=new BeanA_1();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1); }
        if (!cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id FROM bean_a_1 WHERE valueString=${dummy}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${dummy}</dt><dd>is binded to method's parameter <strong>value</strong></dd>
   * </dl>
   *
   * @param value
   * 	is binded to ${dummy}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_1> selectByString(String value) {
    // build where condition
    String[] args={(value==null?null:value)};

    Logger.info(StringUtils.formatSQL("SELECT id FROM bean_a_1 WHERE value_string='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id FROM bean_a_1 WHERE value_string=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_1> resultList=new LinkedList<BeanA_1>();
    BeanA_1 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");

      do
       {
        resultBean=new BeanA_1();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <p>SQL insert:</p>
   * <pre>INSERT INTO bean_a_1 (bean_a2_id, value_string) VALUES (${bean.beanA2Id}, ${bean.valueString})</pre>
   *
   * <p><code>bean.id</code> is automatically updated because it is the primary key</p>
   *
   * <p><strong>Inserted columns:</strong></p>
   * <dl>
   * 	<dt>bean_a2_id</dt><dd>is mapped to <strong>${bean.beanA2Id}</strong></dd>
   * 	<dt>value_string</dt><dd>is mapped to <strong>${bean.valueString}</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is mapped to parameter <strong>bean</strong>
   *
   * @return <strong>id</strong> of inserted record
   */
  @Override
  public int insert(BeanA_1 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    contentValues.put("bean_a2_id", bean.beanA2Id);

    if (bean.valueString!=null) {
      contentValues.put("value_string", bean.valueString);
    } else {
      contentValues.putNull("value_string");
    }

    // log
    Logger.info(StringUtils.formatSQL("SQL: INSERT INTO bean_a_1 (bean_a2_id, value_string) VALUES ('"+StringUtils.checkSize(contentValues.get("bean_a2_id"))+"', '"+StringUtils.checkSize(contentValues.get("value_string"))+"')"));
    long result = database().insert("bean_a_1", null, contentValues);
    bean.id=result;

    return (int)result;
  }

  /**
   * <p>SQL Update:</p>
   * <pre>UPDATE bean_a_1 SET bean_a2_id=${bean.beanA2Id}, value_string=${bean.valueString} WHERE valueString=${bean.valueString}</pre>
   *
   * <p><strong>Updated columns:</strong></p>
   * <dl>
   * 	<dt>bean_a2_id</dt><dd>is mapped to <strong>${bean.beanA2Id}</strong></dd>
   * 	<dt>value_string</dt><dd>is mapped to <strong>${bean.valueString}</strong></dd>
   * </dl>
   *
   * <p><strong>Parameters used in where conditions:</strong></p>
   * <dl>
   * 	<dt>${bean.valueString}</dt><dd>is mapped to method's parameter <strong>bean.valueString</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is used as ${bean}
   *
   * @return number of updated records
   */
  @Override
  public int update(BeanA_1 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    contentValues.put("bean_a2_id", bean.beanA2Id);

    if (bean.valueString!=null) {
      contentValues.put("value_string", bean.valueString);
    } else {
      contentValues.putNull("value_string");
    }

    String[] whereConditions={(bean.valueString==null?null:bean.valueString)};

    Logger.info(StringUtils.formatSQL("UPDATE bean_a_1 SET bean_a2_id='"+StringUtils.checkSize(contentValues.get("bean_a2_id"))+"', value_string='"+StringUtils.checkSize(contentValues.get("value_string"))+"' WHERE valueString='%s'"), (Object[])whereConditions);
    int result = database().update("bean_a_1", contentValues, "value_string=?", whereConditions);
    return result;
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BindBeanA_1Cursor.java:
package sqlite.foreignKey;

import android.database.Cursor;
import java.util.LinkedList;

/**
 * <p>
 * Cursor implementation for entity <code>BeanA_1</code>
 * </p>
 *  @see BeanA_1
 */
public class BindBeanA_1Cursor {
  /**
   * Cursor used to read database
   */
  protected Cursor cursor;

  /**
   * Index for column "id"
   */
  protected int index0;

  /**
   * Index for column "beanA2Id"
   */
  protected int index1;

  /**
   * Index for column "valueString"
   */
  protected int index2;

  /**
   * <p>Constructor</p>
   *
   * @param cursor cursor used to read from database
   */
  BindBeanA_1Cursor(Cursor cursor) {
    wrap(cursor);
  }

  /**
   * <p>Wrap cursor with this class</p>
   *
   * @param cursor cursor to include
   */
  public BindBeanA_1Cursor wrap(Cursor cursor) {
    this.cursor=cursor;

    index0=cursor.getColumnIndex("id");
    index1=cursor.getColumnIndex("bean_a2_id");
    index2=cursor.getColumnIndex("value_string");

    return this;
  }

  /**
   * <p>Execute the cursor and read all rows from database.</p>
   *
   * @return list of beans
   */
  public LinkedList<BeanA_1> execute() {

    LinkedList<BeanA_1> resultList=new LinkedList<BeanA_1>();
    BeanA_1 resultBean=new BeanA_1();

    if (cursor.moveToFirst()) {
      do
       {
        resultBean=new BeanA_1();

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1);}
        if (index2>=0 && !cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2);}

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * Method executed for each row extracted from database. For each row specified listener will be invoked.
   *
   * @param listener listener to invoke for each row
   */
  public void executeListener(OnBeanA_1Listener listener) {
    BeanA_1 resultBean=new BeanA_1();

    if (cursor.moveToFirst()) {
      do
       {
        if (index0>=0) { resultBean.id=0L;}
        if (index1>=0) { resultBean.beanA2Id=0L;}
        if (index2>=0) { resultBean.valueString=null;}

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1);}
        if (index2>=0 && !cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2);}

        listener.onRow(resultBean, cursor.getPosition(),cursor.getCount());
      } while (cursor.moveToNext());
    }
    cursor.close();
  }

  /**
   * <p>Create a binded cursor starting from a cursor</p>
   *
   * @param cursor to wrap
   */
  public static BindBeanA_1Cursor create(Cursor cursor) {
    return new BindBeanA_1Cursor(cursor);
  }

  /**
   * <p>Listener for row read from database.</p>
   */
  public interface OnBeanA_1Listener {
    /**
     * Method executed for each row extracted from database
     *
     * @param bean loaded from database. Only selected columns/fields are valorized
     * @param rowPosition position of row
     * @param rowCount total number of rows
     */
    void onRow(BeanA_1 bean, int rowPosition, int rowCount);
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_1Table.java:
package sqlite.foreignKey;

import java.lang.String;

/**
 * <p>
 * Entity <code>BeanA_1</code> is associated to table <code>bean_a_1</code>
 * This class represents table associated to entity.
 * </p>
 *  @see BeanA_1
 */
public class BeanA_1Table {
  /**
   * Costant represents name of table bean_a_1
   */
  public static final String TABLE_NAME = "bean_a_1";

  /**
   * <p>
   * DDL to create table bean_a_1
   * </p>
   *
   * <pre>CREATE TABLE bean_a_1 (id INTEGER PRIMARY KEY AUTOINCREMENT, bean_a2_id INTEGER, value_string TEXT, FOREIGN KEY(bean_a2_id) REFERENCES bean_a_2(pk));</pre>
   */
  public static final String CREATE_TABLE_SQL = "CREATE TABLE bean_a_1 (id INTEGER PRIMARY KEY AUTOINCREMENT, bean_a2_id INTEGER, value_string TEXT, FOREIGN KEY(bean_a2_id) REFERENCES bean_a_2(pk));";

  /**
   * <p>
   * DDL to drop table bean_a_1
   * </p>
   *
   * <pre>DROP TABLE IF EXISTS bean_a_1;</pre>
   */
  public static final String DROP_TABLE_SQL = "DROP TABLE IF EXISTS bean_a_1;";

  /**
   * Entity's property <code>id</code> is associated to table column <code>id</code>. This costant represents column name.
   *
   *  @see BeanA_1#id
   */
  public static final String COLUMN_ID = "id";

  /**
   * Entity's property <code>beanA2Id</code> is associated to table column <code>bean_a2_id</code>. This costant represents column name.
   *
   *  @see BeanA_1#beanA2Id
   */
  public static final String COLUMN_BEAN_A2_ID = "bean_a2_id";

  /**
   * Entity's property <code>valueString</code> is associated to table column <code>value_string</code>. This costant represents column name.
   *
   *  @see BeanA_1#valueString
   */
  public static final String COLUMN_VALUE_STRING = "value_string";
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_1BindMap.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.AbstractJacksonContext;
import com.abubusoft.kripton.AbstractMapper;
import com.abubusoft.kripton.KriptonXmlContext;
import com.abubusoft.kripton.annotation.BindMap;
import com.abubusoft.kripton.common.PrimitiveUtils;
import com.abubusoft.kripton.escape.StringEscapeUtils;
import com.abubusoft.kripton.exception.KriptonRuntimeException;
import com.abubusoft.kripton.persistence.JacksonWrapperParser;
import com.abubusoft.kripton.persistence.JacksonWrapperSerializer;
import com.abubusoft.kripton.persistence.XmlSerializer;
import com.abubusoft.kripton.persistence.XmlWrapperParser;
import com.abubusoft.kripton.persistence.XmlWrapperSerializer;
import com.abubusoft.kripton.persistence.xml.internal.XmlPullParser;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import java.lang.Exception;
import java.lang.Override;

/**
 * This class is the shared preference binder defined for BeanA_1
 *
 * @see BeanA_1
 */
@BindMap(BeanA_1.class)
public class BeanA_1BindMap extends AbstractMapper<BeanA_1> {
  /**
   * create new object instance
   */
  @Override
  public BeanA_1 createInstance() {
    return new BeanA_1();
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJackson(AbstractJacksonContext context, BeanA_1 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field beanA2Id (mapped with "beanA2Id")
      fieldCount++;
      jacksonSerializer.writeNumberField("beanA2Id", object.beanA2Id);

      // field id (mapped with "id")
      fieldCount++;
      jacksonSerializer.writeNumberField("id", object.id);

      // field valueString (mapped with "valueString")
      if (object.valueString!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString", object.valueString);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJacksonAsString(AbstractJacksonContext context, BeanA_1 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field beanA2Id (mapped with "beanA2Id")
      jacksonSerializer.writeStringField("beanA2Id", PrimitiveUtils.writeLong(object.beanA2Id));

      // field id (mapped with "id")
      jacksonSerializer.writeStringField("id", PrimitiveUtils.writeLong(object.id));

      // field valueString (mapped with "valueString")
      if (object.valueString!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString", object.valueString);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public void serializeOnXml(KriptonXmlContext context, BeanA_1 object, XmlWrapperSerializer wrapper, int currentEventType) {
    try {
      XmlSerializer xmlSerializer = wrapper.xmlSerializer;
      if (currentEventType == 0) {
        xmlSerializer.writeStartElement("beanA_1");
      }

      // Persisted fields:

      // field beanA2Id (mapped with "beanA2Id")
      xmlSerializer.writeStartElement("beanA2Id");
      xmlSerializer.writeLong(object.beanA2Id);
      xmlSerializer.writeEndElement();

      // field id (mapped with "id")
      xmlSerializer.writeStartElement("id");
      xmlSerializer.writeLong(object.id);
      xmlSerializer.writeEndElement();

      // field valueString (mapped with "valueString")
      if (object.valueString!=null) {
        xmlSerializer.writeStartElement("valueString");
        xmlSerializer.writeCharacters(StringEscapeUtils.escapeXml10(object.valueString));
        xmlSerializer.writeEndElement();
      }

      if (currentEventType == 0) {
        xmlSerializer.writeEndElement();
      }
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_1 parseOnJackson(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_1 instance = createInstance();
      String fieldName;
      if (jacksonParser.currentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.currentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "beanA2Id":
              // field beanA2Id (mapped with "beanA2Id")
              instance.beanA2Id=jacksonParser.getLongValue();
            break;
            case "id":
              // field id (mapped with "id")
              instance.id=jacksonParser.getLongValue();
            break;
            case "valueString":
              // field valueString (mapped with "valueString")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_1 parseOnJacksonAsString(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_1 instance = createInstance();
      String fieldName;
      if (jacksonParser.getCurrentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.getCurrentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "beanA2Id":
              // field beanA2Id (mapped with "beanA2Id")
              instance.beanA2Id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "id":
              // field id (mapped with "id")
              instance.id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "valueString":
              // field valueString (mapped with "valueString")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_1 parseOnXml(KriptonXmlContext context, XmlWrapperParser wrapper, int currentEventType) {
    try {
      XmlPullParser xmlParser = wrapper.xmlParser;
      BeanA_1 instance = createInstance();
      int eventType = currentEventType;
      boolean read=true;

      if (currentEventType == 0) {
        eventType = xmlParser.next();
      } else {
        eventType = xmlParser.getEventType();
      }
      String currentTag = xmlParser.getName().toString();
      String elementName = currentTag;
      // No attributes found

      //sub-elements
      while (xmlParser.hasNext() && elementName!=null) {
        if (read) {
          eventType = xmlParser.next();
        } else {
          eventType = xmlParser.getEventType();
        }
        read=true;
        switch(eventType) {
            case XmlPullParser.START_TAG:
              currentTag = xmlParser.getName().toString();
              switch(currentTag) {
                  case "beanA2Id":
                    // property beanA2Id (mapped on "beanA2Id")
                    instance.beanA2Id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "id":
                    // property id (mapped on "id")
                    instance.id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "valueString":
                    // property valueString (mapped on "valueString")
                    instance.valueString=StringEscapeUtils.unescapeXml(xmlParser.getElementText());
                  break;
                  default:
                  break;
                }
              break;
              case XmlPullParser.END_TAG:
                if (elementName.equals(xmlParser.getName())) {
                  currentTag = elementName;
                  elementName = null;
                }
              break;
              case XmlPullParser.CDSECT:
              case XmlPullParser.TEXT:
                // no property is binded to VALUE o CDATA break;
              default:
              break;
          }
        }
        return instance;
      } catch(Exception e) {
        e.printStackTrace();
        throw (new KriptonRuntimeException(e));
      }
    }
  }


/SOURCE_OUTPUT/sqlite/foreignKey/BindDummyDaoFactory.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.android.sqlite.BindDaoFactory;

/**
 * <p>
 * Represents dao factory interface for DummyDataSource.
 * This class expose database interface through Dao attribute.
 * </p>
 *
 * @see DummyDataSource
 * @see DaoBeanA_1
 * @see DaoBeanA_1Impl
 * @see BeanA_1
 * @see DaoBeanA_2
 * @see DaoBeanA_2Impl
 * @see BeanA_2
 */
public interface BindDummyDaoFactory extends BindDaoFactory {
  /**
   *
   * retrieve dao DaoBeanA_1
   */
  DaoBeanA_1Impl getDaoBeanA_1();

  /**
   *
   * retrieve dao DaoBeanA_2
   */
  DaoBeanA_2Impl getDaoBeanA_2();
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_2BindMap.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.AbstractJacksonContext;
import com.abubusoft.kripton.AbstractMapper;
import com.abubusoft.kripton.KriptonXmlContext;
import com.abubusoft.kripton.annotation.BindMap;
import com.abubusoft.kripton.common.PrimitiveUtils;
import com.abubusoft.kripton.escape.StringEscapeUtils;
import com.abubusoft.kripton.exception.KriptonRuntimeException;
import com.abubusoft.kripton.persistence.JacksonWrapperParser;
import com.abubusoft.kripton.persistence.JacksonWrapperSerializer;
import com.abubusoft.kripton.persistence.XmlSerializer;
import com.abubusoft.kripton.persistence.XmlWrapperParser;
import com.abubusoft.kripton.persistence.XmlWrapperSerializer;
import com.abubusoft.kripton.persistence.xml.internal.XmlPullParser;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import java.lang.Exception;
import java.lang.Override;

/**
 * This class is the shared preference binder defined for BeanA_2
 *
 * @see BeanA_2
 */
@BindMap(BeanA_2.class)
public class BeanA_2BindMap extends AbstractMapper<BeanA_2> {
  /**
   * create new object instance
   */
  @Override
  public BeanA_2 createInstance() {
    return new BeanA_2();
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJackson(AbstractJacksonContext context, BeanA_2 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field id (mapped with "id")
      fieldCount++;
      jacksonSerializer.writeNumberField("id", object.id);

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString2", object.valueString2);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJacksonAsString(AbstractJacksonContext context, BeanA_2 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field id (mapped with "id")
      jacksonSerializer.writeStringField("id", PrimitiveUtils.writeLong(object.id));

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString2", object.valueString2);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public void serializeOnXml(KriptonXmlContext context, BeanA_2 object, XmlWrapperSerializer wrapper, int currentEventType) {
    try {
      XmlSerializer xmlSerializer = wrapper.xmlSerializer;
      if (currentEventType == 0) {
        xmlSerializer.writeStartElement("beanA_2");
      }

      // Persisted fields:

      // field id (mapped with "id")
      xmlSerializer.writeStartElement("id");
      xmlSerializer.writeLong(object.id);
      xmlSerializer.writeEndElement();

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null) {
        xmlSerializer.writeStartElement("valueString2");
        xmlSerializer.writeCharacters(StringEscapeUtils.escapeXml10(object.valueString2));
        xmlSerializer.writeEndElement();
      }

      if (currentEventType == 0) {
        xmlSerializer.writeEndElement();
      }
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_2 parseOnJackson(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_2 instance = createInstance();
      String fieldName;
      if (jacksonParser.currentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.currentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "id":
              // field id (mapped with "id")
              instance.id=jacksonParser.getLongValue();
            break;
            case "valueString2":
              // field valueString2 (mapped with "valueString2")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString2=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_2 parseOnJacksonAsString(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_2 instance = createInstance();
      String fieldName;
      if (jacksonParser.getCurrentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.getCurrentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "id":
              // field id (mapped with "id")
              instance.id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "valueString2":
              // field valueString2 (mapped with "valueString2")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString2=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_2 parseOnXml(KriptonXmlContext context, XmlWrapperParser wrapper, int currentEventType) {
    try {
      XmlPullParser xmlParser = wrapper.xmlParser;
      BeanA_2 instance = createInstance();
      int eventType = currentEventType;
      boolean read=true;

      if (currentEventType == 0) {
        eventType = xmlParser.next();
      } else {
        eventType = xmlParser.getEventType();
      }
      String currentTag = xmlParser.getName().toString();
      String elementName = currentTag;
      // No attributes found

      //sub-elements
      while (xmlParser.hasNext() && elementName!=null) {
        if (read) {
          eventType = xmlParser.next();
        } else {
          eventType = xmlParser.getEventType();
        }
        read=true;
        switch(eventType) {
            case XmlPullParser.START_TAG:
              currentTag = xmlParser.getName().toString();
              switch(currentTag) {
                  case "id":
                    // property id (mapped on "id")
                    instance.id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "valueString2":
                    // property valueString2 (mapped on "valueString2")
                    instance.valueString2=StringEscapeUtils.unescapeXml(xmlParser.getElementText());
                  break;
                  default:
                  break;
                }
              break;
              case XmlPullParser.END_TAG:
                if (elementName.equals(xmlParser.getName())) {
                  currentTag = elementName;
                  elementName = null;
                }
              break;
              case XmlPullParser.CDSECT:
              case XmlPullParser.TEXT:
                // no property is binded to VALUE o CDATA break;
              default:
              break;
          }
        }
        return instance;
      } catch(Exception e) {
        e.printStackTrace();
        throw (new KriptonRuntimeException(e));
      }
    }
  }


/SOURCE_OUTPUT/sqlite/foreignKey/BindBeanA_2Cursor.java:
package sqlite.foreignKey;

import android.database.Cursor;
import java.util.LinkedList;

/**
 * <p>
 * Cursor implementation for entity <code>BeanA_2</code>
 * </p>
 *  @see BeanA_2
 */
public class BindBeanA_2Cursor {
  /**
   * Cursor used to read database
   */
  protected Cursor cursor;

  /**
   * Index for column "id"
   */
  protected int index0;

  /**
   * Index for column "valueString2"
   */
  protected int index1;

  /**
   * <p>Constructor</p>
   *
   * @param cursor cursor used to read from database
   */
  BindBeanA_2Cursor(Cursor cursor) {
    wrap(cursor);
  }

  /**
   * <p>Wrap cursor with this class</p>
   *
   * @param cursor cursor to include
   */
  public BindBeanA_2Cursor wrap(Cursor cursor) {
    this.cursor=cursor;

    index0=cursor.getColumnIndex("id");
    index1=cursor.getColumnIndex("value_string2");

    return this;
  }

  /**
   * <p>Execute the cursor and read all rows from database.</p>
   *
   * @return list of beans
   */
  public LinkedList<BeanA_2> execute() {

    LinkedList<BeanA_2> resultList=new LinkedList<BeanA_2>();
    BeanA_2 resultBean=new BeanA_2();

    if (cursor.moveToFirst()) {
      do
       {
        resultBean=new BeanA_2();

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1);}

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * Method executed for each row extracted from database. For each row specified listener will be invoked.
   *
   * @param listener listener to invoke for each row
   */
  public void executeListener(OnBeanA_2Listener listener) {
    BeanA_2 resultBean=new BeanA_2();

    if (cursor.moveToFirst()) {
      do
       {
        if (index0>=0) { resultBean.id=0L;}
        if (index1>=0) { resultBean.valueString2=null;}

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1);}

        listener.onRow(resultBean, cursor.getPosition(),cursor.getCount());
      } while (cursor.moveToNext());
    }
    cursor.close();
  }

  /**
   * <p>Create a binded cursor starting from a cursor</p>
   *
   * @param cursor to wrap
   */
  public static BindBeanA_2Cursor create(Cursor cursor) {
    return new BindBeanA_2Cursor(cursor);
  }

  /**
   * <p>Listener for row read from database.</p>
   */
  public interface OnBeanA_2Listener {
    /**
     * Method executed for each row extracted from database
     *
     * @param bean loaded from database. Only selected columns/fields are valorized
     * @param rowPosition position of row
     * @param rowCount total number of rows
     */
    void onRow(BeanA_2 bean, int rowPosition, int rowCount);
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/DaoBeanA_2Impl.java:
package sqlite.foreignKey;

import android.content.ContentValues;
import android.database.Cursor;
import com.abubusoft.kripton.android.Logger;
import com.abubusoft.kripton.android.sqlite.AbstractDao;
import com.abubusoft.kripton.common.StringUtils;
import java.util.LinkedList;
import java.util.List;

/**
 * <p>
 * DAO implementation for entity <code>BeanA_2</code>, based on interface <code>DaoBeanA_2</code>
 * </p>
 *
 *  @see BeanA_2
 *  @see DaoBeanA_2
 *  @see BeanA_2Table
 */
public class DaoBeanA_2Impl extends AbstractDao implements DaoBeanA_2 {
  public DaoBeanA_2Impl(BindDummyDataSource dataSet) {
    super(dataSet);
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, value_string2 FROM bean_a_2 WHERE 1=1</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>value_string2</dt><dd>is associated to bean's property <strong>valueString2</strong></dd>
   * </dl>
   *
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_2> selectAll() {
    // build where condition
    String[] args={};

    Logger.info(StringUtils.formatSQL("SELECT id, value_string2 FROM bean_a_2 WHERE 1=1"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, value_string2 FROM bean_a_2 WHERE 1=1", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_2> resultList=new LinkedList<BeanA_2>();
    BeanA_2 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("value_string2");

      do
       {
        resultBean=new BeanA_2();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, value_string2 FROM bean_a_2 WHERE id=${id}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>value_string2</dt><dd>is associated to bean's property <strong>valueString2</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${id}</dt><dd>is binded to method's parameter <strong>id</strong></dd>
   * </dl>
   *
   * @param id
   * 	is binded to ${id}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_2> selectById(long id) {
    // build where condition
    String[] args={String.valueOf(id)};

    Logger.info(StringUtils.formatSQL("SELECT id, value_string2 FROM bean_a_2 WHERE id='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, value_string2 FROM bean_a_2 WHERE id=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_2> resultList=new LinkedList<BeanA_2>();
    BeanA_2 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("value_string2");

      do
       {
        resultBean=new BeanA_2();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id FROM bean_a_2 WHERE valueString2=${dummy}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${dummy}</dt><dd>is binded to method's parameter <strong>value</strong></dd>
   * </dl>
   *
   * @param value
   * 	is binded to ${dummy}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_2> selectByString(String value) {
    // build where condition
    String[] args={(value==null?null:value)};

    Logger.info(StringUtils.formatSQL("SELECT id FROM bean_a_2 WHERE value_string2='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id FROM bean_a_2 WHERE value_string2=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_2> resultList=new LinkedList<BeanA_2>();
    BeanA_2 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");

      do
       {
        resultBean=new BeanA_2();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <p>SQL insert:</p>
   * <pre>INSERT INTO bean_a_2 (value_string2) VALUES (${bean.valueString2})</pre>
   *
   * <p><code>bean.id</code> is automatically updated because it is the primary key</p>
   *
   * <p><strong>Inserted columns:</strong></p>
   * <dl>
   * 	<dt>value_string2</dt><dd>is mapped to <strong>${bean.valueString2}</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is mapped to parameter <strong>bean</strong>
   *
   * @return <strong>id</strong> of inserted record
   */
  @Override
  public int insert(BeanA_2 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.valueString2!=null) {
      contentValues.put("value_string2", bean.valueString2);
    } else {
      contentValues.putNull("value_string2");
    }

    // log
    Logger.info(StringUtils.formatSQL("SQL: INSERT INTO bean_a_2 (value_string2) VALUES ('"+StringUtils.checkSize(contentValues.get("value_string2"))+"')"));
    long result = database().insert("bean_a_2", null, contentValues);
    bean.id=result;

    return (int)result;
  }

  /**
   * <p>SQL Update:</p>
   * <pre>UPDATE bean_a_2 SET value_string2=${bean.valueString2} WHERE valueString2=${bean.valueString2}</pre>
   *
   * <p><strong>Updated columns:</strong></p>
   * <dl>
   * 	<dt>value_string2</dt><dd>is mapped to <strong>${bean.valueString2}</strong></dd>
   * </dl>
   *
   * <p><strong>Parameters used in where conditions:</strong></p>
   * <dl>
   * 	<dt>${bean.valueString2}</dt><dd>is mapped to method's parameter <strong>bean.valueString2</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is used as ${bean}
   *
   * @return number of updated records
   */
  @Override
  public int update(BeanA_2 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.valueString2!=null) {
      contentValues.put("value_string2", bean.valueString2);
    } else {
      contentValues.putNull("value_string2");
    }

    String[] whereConditions={(bean.valueString2==null?null:bean.valueString2)};

    Logger.info(StringUtils.formatSQL("UPDATE bean_a_2 SET value_string2='"+StringUtils.checkSize(contentValues.get("value_string2"))+"' WHERE valueString2='%s'"), (Object[])whereConditions);
    int result = database().update("bean_a_2", contentValues, "value_string2=?", whereConditions);
    return result;
  }
}


	at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:24)
	at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:20)
	at com.abubusoft.testing.compile.JavaSourcesSubject$CompilationClause.successfulCompilationResult(JavaSourcesSubject.java:310)
	at com.abubusoft.testing.compile.JavaSourcesSubject$CompilationClause.compilesWithoutError(JavaSourcesSubject.java:289)
	at base.BaseProcessorTest.buildTest(BaseProcessorTest.java:255)
	at base.BaseProcessorTest.buildDataSourceProcessorTest(BaseProcessorTest.java:231)
	at sqlite.foreignKey.TestForeignKeyCompile.testForeignKeyCompile1(TestForeignKeyCompile.java:44)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.rules.ExpectedException$ExpectedExceptionStatement.evaluate(ExpectedException.java:239)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)

testForeignKeyCompile3(sqlite.foreignKey.TestForeignKeyCompile)  Time elapsed: 0.127 sec  <<< FAILURE!
java.lang.AssertionError: Compilation produced the following errors:

error: com.abubusoft.kripton.processor.exceptions.CircularRelationshipException: Table definition bean_a_6 is in a circular dependency


Generated Files
===============

/SOURCE_OUTPUT/sqlite/foreignKey/BindBeanA_5Cursor.java:
package sqlite.foreignKey;

import android.database.Cursor;
import java.util.LinkedList;

/**
 * <p>
 * Cursor implementation for entity <code>BeanA_5</code>
 * </p>
 *  @see BeanA_5
 */
public class BindBeanA_5Cursor {
  /**
   * Cursor used to read database
   */
  protected Cursor cursor;

  /**
   * Index for column "id"
   */
  protected int index0;

  /**
   * Index for column "beanA2Id"
   */
  protected int index1;

  /**
   * Index for column "valueString"
   */
  protected int index2;

  /**
   * <p>Constructor</p>
   *
   * @param cursor cursor used to read from database
   */
  BindBeanA_5Cursor(Cursor cursor) {
    wrap(cursor);
  }

  /**
   * <p>Wrap cursor with this class</p>
   *
   * @param cursor cursor to include
   */
  public BindBeanA_5Cursor wrap(Cursor cursor) {
    this.cursor=cursor;

    index0=cursor.getColumnIndex("id");
    index1=cursor.getColumnIndex("bean_a2_id");
    index2=cursor.getColumnIndex("value_string");

    return this;
  }

  /**
   * <p>Execute the cursor and read all rows from database.</p>
   *
   * @return list of beans
   */
  public LinkedList<BeanA_5> execute() {

    LinkedList<BeanA_5> resultList=new LinkedList<BeanA_5>();
    BeanA_5 resultBean=new BeanA_5();

    if (cursor.moveToFirst()) {
      do
       {
        resultBean=new BeanA_5();

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1);}
        if (index2>=0 && !cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2);}

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * Method executed for each row extracted from database. For each row specified listener will be invoked.
   *
   * @param listener listener to invoke for each row
   */
  public void executeListener(OnBeanA_5Listener listener) {
    BeanA_5 resultBean=new BeanA_5();

    if (cursor.moveToFirst()) {
      do
       {
        if (index0>=0) { resultBean.id=0L;}
        if (index1>=0) { resultBean.beanA2Id=null;}
        if (index2>=0) { resultBean.valueString=null;}

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1);}
        if (index2>=0 && !cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2);}

        listener.onRow(resultBean, cursor.getPosition(),cursor.getCount());
      } while (cursor.moveToNext());
    }
    cursor.close();
  }

  /**
   * <p>Create a binded cursor starting from a cursor</p>
   *
   * @param cursor to wrap
   */
  public static BindBeanA_5Cursor create(Cursor cursor) {
    return new BindBeanA_5Cursor(cursor);
  }

  /**
   * <p>Listener for row read from database.</p>
   */
  public interface OnBeanA_5Listener {
    /**
     * Method executed for each row extracted from database
     *
     * @param bean loaded from database. Only selected columns/fields are valorized
     * @param rowPosition position of row
     * @param rowCount total number of rows
     */
    void onRow(BeanA_5 bean, int rowPosition, int rowCount);
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/DaoBeanA_6Impl.java:
package sqlite.foreignKey;

import android.content.ContentValues;
import android.database.Cursor;
import com.abubusoft.kripton.android.Logger;
import com.abubusoft.kripton.android.sqlite.AbstractDao;
import com.abubusoft.kripton.common.StringUtils;
import java.util.LinkedList;
import java.util.List;

/**
 * <p>
 * DAO implementation for entity <code>BeanA_6</code>, based on interface <code>DaoBeanA_6</code>
 * </p>
 *
 *  @see BeanA_6
 *  @see DaoBeanA_6
 *  @see BeanA_6Table
 */
public class DaoBeanA_6Impl extends AbstractDao implements DaoBeanA_6 {
  public DaoBeanA_6Impl(BindDummy3DataSource dataSet) {
    super(dataSet);
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, value_string2 FROM bean_a_6 WHERE 1=1</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>value_string2</dt><dd>is associated to bean's property <strong>valueString2</strong></dd>
   * </dl>
   *
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_6> selectAll() {
    // build where condition
    String[] args={};

    Logger.info(StringUtils.formatSQL("SELECT id, value_string2 FROM bean_a_6 WHERE 1=1"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, value_string2 FROM bean_a_6 WHERE 1=1", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_6> resultList=new LinkedList<BeanA_6>();
    BeanA_6 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("value_string2");

      do
       {
        resultBean=new BeanA_6();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, value_string2 FROM bean_a_6 WHERE id=${id}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>value_string2</dt><dd>is associated to bean's property <strong>valueString2</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${id}</dt><dd>is binded to method's parameter <strong>id</strong></dd>
   * </dl>
   *
   * @param id
   * 	is binded to ${id}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_6> selectById(long id) {
    // build where condition
    String[] args={String.valueOf(id)};

    Logger.info(StringUtils.formatSQL("SELECT id, value_string2 FROM bean_a_6 WHERE id='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, value_string2 FROM bean_a_6 WHERE id=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_6> resultList=new LinkedList<BeanA_6>();
    BeanA_6 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("value_string2");

      do
       {
        resultBean=new BeanA_6();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id FROM bean_a_6 WHERE valueString2=${dummy}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${dummy}</dt><dd>is binded to method's parameter <strong>value</strong></dd>
   * </dl>
   *
   * @param value
   * 	is binded to ${dummy}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_6> selectByString(String value) {
    // build where condition
    String[] args={(value==null?null:value)};

    Logger.info(StringUtils.formatSQL("SELECT id FROM bean_a_6 WHERE value_string2='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id FROM bean_a_6 WHERE value_string2=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_6> resultList=new LinkedList<BeanA_6>();
    BeanA_6 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");

      do
       {
        resultBean=new BeanA_6();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <p>SQL insert:</p>
   * <pre>INSERT INTO bean_a_6 (value_string2) VALUES (${bean.valueString2})</pre>
   *
   * <p><code>bean.id</code> is automatically updated because it is the primary key</p>
   *
   * <p><strong>Inserted columns:</strong></p>
   * <dl>
   * 	<dt>value_string2</dt><dd>is mapped to <strong>${bean.valueString2}</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is mapped to parameter <strong>bean</strong>
   *
   * @return <strong>id</strong> of inserted record
   */
  @Override
  public int insert(BeanA_6 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.valueString2!=null) {
      contentValues.put("value_string2", bean.valueString2);
    } else {
      contentValues.putNull("value_string2");
    }

    // log
    Logger.info(StringUtils.formatSQL("SQL: INSERT INTO bean_a_6 (value_string2) VALUES ('"+StringUtils.checkSize(contentValues.get("value_string2"))+"')"));
    long result = database().insert("bean_a_6", null, contentValues);
    bean.id=result;

    return (int)result;
  }

  /**
   * <p>SQL Update:</p>
   * <pre>UPDATE bean_a_6 SET value_string2=${bean.valueString2} WHERE valueString2=${bean.valueString2}</pre>
   *
   * <p><strong>Updated columns:</strong></p>
   * <dl>
   * 	<dt>value_string2</dt><dd>is mapped to <strong>${bean.valueString2}</strong></dd>
   * </dl>
   *
   * <p><strong>Parameters used in where conditions:</strong></p>
   * <dl>
   * 	<dt>${bean.valueString2}</dt><dd>is mapped to method's parameter <strong>bean.valueString2</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is used as ${bean}
   *
   * @return number of updated records
   */
  @Override
  public int update(BeanA_6 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.valueString2!=null) {
      contentValues.put("value_string2", bean.valueString2);
    } else {
      contentValues.putNull("value_string2");
    }

    String[] whereConditions={(bean.valueString2==null?null:bean.valueString2)};

    Logger.info(StringUtils.formatSQL("UPDATE bean_a_6 SET value_string2='"+StringUtils.checkSize(contentValues.get("value_string2"))+"' WHERE valueString2='%s'"), (Object[])whereConditions);
    int result = database().update("bean_a_6", contentValues, "value_string2=?", whereConditions);
    return result;
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_5BindMap.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.AbstractJacksonContext;
import com.abubusoft.kripton.AbstractMapper;
import com.abubusoft.kripton.KriptonXmlContext;
import com.abubusoft.kripton.annotation.BindMap;
import com.abubusoft.kripton.common.PrimitiveUtils;
import com.abubusoft.kripton.escape.StringEscapeUtils;
import com.abubusoft.kripton.exception.KriptonRuntimeException;
import com.abubusoft.kripton.persistence.JacksonWrapperParser;
import com.abubusoft.kripton.persistence.JacksonWrapperSerializer;
import com.abubusoft.kripton.persistence.XmlSerializer;
import com.abubusoft.kripton.persistence.XmlWrapperParser;
import com.abubusoft.kripton.persistence.XmlWrapperSerializer;
import com.abubusoft.kripton.persistence.xml.internal.XmlPullParser;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import java.lang.Exception;
import java.lang.Override;

/**
 * This class is the shared preference binder defined for BeanA_5
 *
 * @see BeanA_5
 */
@BindMap(BeanA_5.class)
public class BeanA_5BindMap extends AbstractMapper<BeanA_5> {
  /**
   * create new object instance
   */
  @Override
  public BeanA_5 createInstance() {
    return new BeanA_5();
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJackson(AbstractJacksonContext context, BeanA_5 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field beanA2Id (mapped with "beanA2Id")
      if (object.beanA2Id!=null)  {
        fieldCount++;
        jacksonSerializer.writeNumberField("beanA2Id", object.beanA2Id);
      }

      // field id (mapped with "id")
      fieldCount++;
      jacksonSerializer.writeNumberField("id", object.id);

      // field valueString (mapped with "valueString")
      if (object.valueString!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString", object.valueString);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJacksonAsString(AbstractJacksonContext context, BeanA_5 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field beanA2Id (mapped with "beanA2Id")
      if (object.beanA2Id!=null)  {
        jacksonSerializer.writeStringField("beanA2Id", PrimitiveUtils.writeLong(object.beanA2Id));
      }

      // field id (mapped with "id")
      jacksonSerializer.writeStringField("id", PrimitiveUtils.writeLong(object.id));

      // field valueString (mapped with "valueString")
      if (object.valueString!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString", object.valueString);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public void serializeOnXml(KriptonXmlContext context, BeanA_5 object, XmlWrapperSerializer wrapper, int currentEventType) {
    try {
      XmlSerializer xmlSerializer = wrapper.xmlSerializer;
      if (currentEventType == 0) {
        xmlSerializer.writeStartElement("beanA_5");
      }

      // Persisted fields:

      // field beanA2Id (mapped with "beanA2Id")
      if (object.beanA2Id!=null)  {
        xmlSerializer.writeStartElement("beanA2Id");
        xmlSerializer.writeLong(object.beanA2Id);
        xmlSerializer.writeEndElement();
      }

      // field id (mapped with "id")
      xmlSerializer.writeStartElement("id");
      xmlSerializer.writeLong(object.id);
      xmlSerializer.writeEndElement();

      // field valueString (mapped with "valueString")
      if (object.valueString!=null) {
        xmlSerializer.writeStartElement("valueString");
        xmlSerializer.writeCharacters(StringEscapeUtils.escapeXml10(object.valueString));
        xmlSerializer.writeEndElement();
      }

      if (currentEventType == 0) {
        xmlSerializer.writeEndElement();
      }
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_5 parseOnJackson(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_5 instance = createInstance();
      String fieldName;
      if (jacksonParser.currentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.currentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "beanA2Id":
              // field beanA2Id (mapped with "beanA2Id")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.beanA2Id=jacksonParser.getLongValue();
              }
            break;
            case "id":
              // field id (mapped with "id")
              instance.id=jacksonParser.getLongValue();
            break;
            case "valueString":
              // field valueString (mapped with "valueString")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_5 parseOnJacksonAsString(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_5 instance = createInstance();
      String fieldName;
      if (jacksonParser.getCurrentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.getCurrentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "beanA2Id":
              // field beanA2Id (mapped with "beanA2Id")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.beanA2Id=PrimitiveUtils.readLong(jacksonParser.getText(), null);
              }
            break;
            case "id":
              // field id (mapped with "id")
              instance.id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "valueString":
              // field valueString (mapped with "valueString")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_5 parseOnXml(KriptonXmlContext context, XmlWrapperParser wrapper, int currentEventType) {
    try {
      XmlPullParser xmlParser = wrapper.xmlParser;
      BeanA_5 instance = createInstance();
      int eventType = currentEventType;
      boolean read=true;

      if (currentEventType == 0) {
        eventType = xmlParser.next();
      } else {
        eventType = xmlParser.getEventType();
      }
      String currentTag = xmlParser.getName().toString();
      String elementName = currentTag;
      // No attributes found

      //sub-elements
      while (xmlParser.hasNext() && elementName!=null) {
        if (read) {
          eventType = xmlParser.next();
        } else {
          eventType = xmlParser.getEventType();
        }
        read=true;
        switch(eventType) {
            case XmlPullParser.START_TAG:
              currentTag = xmlParser.getName().toString();
              switch(currentTag) {
                  case "beanA2Id":
                    // property beanA2Id (mapped on "beanA2Id")
                    instance.beanA2Id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), null);
                  break;
                  case "id":
                    // property id (mapped on "id")
                    instance.id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "valueString":
                    // property valueString (mapped on "valueString")
                    instance.valueString=StringEscapeUtils.unescapeXml(xmlParser.getElementText());
                  break;
                  default:
                  break;
                }
              break;
              case XmlPullParser.END_TAG:
                if (elementName.equals(xmlParser.getName())) {
                  currentTag = elementName;
                  elementName = null;
                }
              break;
              case XmlPullParser.CDSECT:
              case XmlPullParser.TEXT:
                // no property is binded to VALUE o CDATA break;
              default:
              break;
          }
        }
        return instance;
      } catch(Exception e) {
        e.printStackTrace();
        throw (new KriptonRuntimeException(e));
      }
    }
  }


/SOURCE_OUTPUT/sqlite/foreignKey/BindDummy3DaoFactory.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.android.sqlite.BindDaoFactory;

/**
 * <p>
 * Represents dao factory interface for Dummy3DataSource.
 * This class expose database interface through Dao attribute.
 * </p>
 *
 * @see Dummy3DataSource
 * @see DaoBeanA_5
 * @see DaoBeanA_5Impl
 * @see BeanA_5
 * @see DaoBeanA_6
 * @see DaoBeanA_6Impl
 * @see BeanA_6
 */
public interface BindDummy3DaoFactory extends BindDaoFactory {
  /**
   *
   * retrieve dao DaoBeanA_5
   */
  DaoBeanA_5Impl getDaoBeanA_5();

  /**
   *
   * retrieve dao DaoBeanA_6
   */
  DaoBeanA_6Impl getDaoBeanA_6();
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_6BindMap.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.AbstractJacksonContext;
import com.abubusoft.kripton.AbstractMapper;
import com.abubusoft.kripton.KriptonXmlContext;
import com.abubusoft.kripton.annotation.BindMap;
import com.abubusoft.kripton.common.PrimitiveUtils;
import com.abubusoft.kripton.escape.StringEscapeUtils;
import com.abubusoft.kripton.exception.KriptonRuntimeException;
import com.abubusoft.kripton.persistence.JacksonWrapperParser;
import com.abubusoft.kripton.persistence.JacksonWrapperSerializer;
import com.abubusoft.kripton.persistence.XmlSerializer;
import com.abubusoft.kripton.persistence.XmlWrapperParser;
import com.abubusoft.kripton.persistence.XmlWrapperSerializer;
import com.abubusoft.kripton.persistence.xml.internal.XmlPullParser;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import java.lang.Exception;
import java.lang.Override;

/**
 * This class is the shared preference binder defined for BeanA_6
 *
 * @see BeanA_6
 */
@BindMap(BeanA_6.class)
public class BeanA_6BindMap extends AbstractMapper<BeanA_6> {
  /**
   * create new object instance
   */
  @Override
  public BeanA_6 createInstance() {
    return new BeanA_6();
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJackson(AbstractJacksonContext context, BeanA_6 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field id (mapped with "id")
      fieldCount++;
      jacksonSerializer.writeNumberField("id", object.id);

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString2", object.valueString2);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJacksonAsString(AbstractJacksonContext context, BeanA_6 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field id (mapped with "id")
      jacksonSerializer.writeStringField("id", PrimitiveUtils.writeLong(object.id));

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString2", object.valueString2);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public void serializeOnXml(KriptonXmlContext context, BeanA_6 object, XmlWrapperSerializer wrapper, int currentEventType) {
    try {
      XmlSerializer xmlSerializer = wrapper.xmlSerializer;
      if (currentEventType == 0) {
        xmlSerializer.writeStartElement("beanA_6");
      }

      // Persisted fields:

      // field id (mapped with "id")
      xmlSerializer.writeStartElement("id");
      xmlSerializer.writeLong(object.id);
      xmlSerializer.writeEndElement();

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null) {
        xmlSerializer.writeStartElement("valueString2");
        xmlSerializer.writeCharacters(StringEscapeUtils.escapeXml10(object.valueString2));
        xmlSerializer.writeEndElement();
      }

      if (currentEventType == 0) {
        xmlSerializer.writeEndElement();
      }
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_6 parseOnJackson(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_6 instance = createInstance();
      String fieldName;
      if (jacksonParser.currentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.currentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "id":
              // field id (mapped with "id")
              instance.id=jacksonParser.getLongValue();
            break;
            case "valueString2":
              // field valueString2 (mapped with "valueString2")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString2=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_6 parseOnJacksonAsString(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_6 instance = createInstance();
      String fieldName;
      if (jacksonParser.getCurrentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.getCurrentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "id":
              // field id (mapped with "id")
              instance.id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "valueString2":
              // field valueString2 (mapped with "valueString2")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString2=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_6 parseOnXml(KriptonXmlContext context, XmlWrapperParser wrapper, int currentEventType) {
    try {
      XmlPullParser xmlParser = wrapper.xmlParser;
      BeanA_6 instance = createInstance();
      int eventType = currentEventType;
      boolean read=true;

      if (currentEventType == 0) {
        eventType = xmlParser.next();
      } else {
        eventType = xmlParser.getEventType();
      }
      String currentTag = xmlParser.getName().toString();
      String elementName = currentTag;
      // No attributes found

      //sub-elements
      while (xmlParser.hasNext() && elementName!=null) {
        if (read) {
          eventType = xmlParser.next();
        } else {
          eventType = xmlParser.getEventType();
        }
        read=true;
        switch(eventType) {
            case XmlPullParser.START_TAG:
              currentTag = xmlParser.getName().toString();
              switch(currentTag) {
                  case "id":
                    // property id (mapped on "id")
                    instance.id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "valueString2":
                    // property valueString2 (mapped on "valueString2")
                    instance.valueString2=StringEscapeUtils.unescapeXml(xmlParser.getElementText());
                  break;
                  default:
                  break;
                }
              break;
              case XmlPullParser.END_TAG:
                if (elementName.equals(xmlParser.getName())) {
                  currentTag = elementName;
                  elementName = null;
                }
              break;
              case XmlPullParser.CDSECT:
              case XmlPullParser.TEXT:
                // no property is binded to VALUE o CDATA break;
              default:
              break;
          }
        }
        return instance;
      } catch(Exception e) {
        e.printStackTrace();
        throw (new KriptonRuntimeException(e));
      }
    }
  }


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_5Table.java:
package sqlite.foreignKey;

import java.lang.String;

/**
 * <p>
 * Entity <code>BeanA_5</code> is associated to table <code>bean_a_5</code>
 * This class represents table associated to entity.
 * </p>
 *  @see BeanA_5
 */
public class BeanA_5Table {
  /**
   * Costant represents name of table bean_a_5
   */
  public static final String TABLE_NAME = "bean_a_5";

  /**
   * <p>
   * DDL to create table bean_a_5
   * </p>
   *
   * <pre>CREATE TABLE bean_a_5 (id INTEGER PRIMARY KEY AUTOINCREMENT, bean_a2_id INTEGER NOT NULL, value_string TEXT, FOREIGN KEY(bean_a2_id) REFERENCES bean_a_6(pk));</pre>
   */
  public static final String CREATE_TABLE_SQL = "CREATE TABLE bean_a_5 (id INTEGER PRIMARY KEY AUTOINCREMENT, bean_a2_id INTEGER NOT NULL, value_string TEXT, FOREIGN KEY(bean_a2_id) REFERENCES bean_a_6(pk));";

  /**
   * <p>
   * DDL to drop table bean_a_5
   * </p>
   *
   * <pre>DROP TABLE IF EXISTS bean_a_5;</pre>
   */
  public static final String DROP_TABLE_SQL = "DROP TABLE IF EXISTS bean_a_5;";

  /**
   * Entity's property <code>id</code> is associated to table column <code>id</code>. This costant represents column name.
   *
   *  @see BeanA_5#id
   */
  public static final String COLUMN_ID = "id";

  /**
   * Entity's property <code>beanA2Id</code> is associated to table column <code>bean_a2_id</code>. This costant represents column name.
   *
   *  @see BeanA_5#beanA2Id
   */
  public static final String COLUMN_BEAN_A2_ID = "bean_a2_id";

  /**
   * Entity's property <code>valueString</code> is associated to table column <code>value_string</code>. This costant represents column name.
   *
   *  @see BeanA_5#valueString
   */
  public static final String COLUMN_VALUE_STRING = "value_string";
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_6Table.java:
package sqlite.foreignKey;

import java.lang.String;

/**
 * <p>
 * Entity <code>BeanA_6</code> is associated to table <code>bean_a_6</code>
 * This class represents table associated to entity.
 * </p>
 *  @see BeanA_6
 */
public class BeanA_6Table {
  /**
   * Costant represents name of table bean_a_6
   */
  public static final String TABLE_NAME = "bean_a_6";

  /**
   * <p>
   * DDL to create table bean_a_6
   * </p>
   *
   * <pre>CREATE TABLE bean_a_6 (pk INTEGER PRIMARY KEY AUTOINCREMENT, value_string2 TEXT);</pre>
   */
  public static final String CREATE_TABLE_SQL = "CREATE TABLE bean_a_6 (pk INTEGER PRIMARY KEY AUTOINCREMENT, value_string2 TEXT);";

  /**
   * <p>
   * DDL to drop table bean_a_6
   * </p>
   *
   * <pre>DROP TABLE IF EXISTS bean_a_6;</pre>
   */
  public static final String DROP_TABLE_SQL = "DROP TABLE IF EXISTS bean_a_6;";

  /**
   * Entity's property <code>id</code> is associated to table column <code>pk</code>. This costant represents column name.
   *
   *  @see BeanA_6#id
   */
  public static final String COLUMN_ID = "pk";

  /**
   * Entity's property <code>valueString2</code> is associated to table column <code>value_string2</code>. This costant represents column name.
   *
   *  @see BeanA_6#valueString2
   */
  public static final String COLUMN_VALUE_STRING2 = "value_string2";
}


/SOURCE_OUTPUT/sqlite/foreignKey/BindDummy3AsyncTask.java:
package sqlite.foreignKey;

import android.os.AsyncTask;
import java.lang.Override;
import java.lang.SuppressWarnings;

/**
 *
 * <p>
 * Specialized async task to make async database operation on activity
 * </p>
 *
 * <p>
 * Unlike standard async task, for an instance of this class can be used many time.
 * </p>
 *
 * <p>
 * When method <code>execute</code> is invoked, an inner async task is created.
 * </p>
 *
 * @see BindDummy3DaoFactory
 * @see BindDummy3DataSource
 */
public abstract class BindDummy3AsyncTask<I, U, R> {
  /**
   * If <code>true</code> indicates database operations are only read operations
   *
   */
  protected boolean readOnlyTask;

  /**
   * Async task wrapped by this class
   *
   */
  protected AsyncTask<I, U, R> asyncTask;

  /**
   * <p>
   * With this constructor, a read only database connection will be used
   * </p>
   */
  public BindDummy3AsyncTask() {
    this(true);}

  /**
   * <p>
   * With this constructor it is possible to specify which type of database use in async task
   * </p>
   *
   * @param readOnlyTask if true, force async task to use read only database connection
   */
  public BindDummy3AsyncTask(boolean readOnlyTask) {
    this.readOnlyTask = readOnlyTask;}

  /**
   * Use this method for operations on UI-thread before start execution
   */
  public void onPreExecute() {
  }

  /**
   * Method used to encapsulate operations on datasource
   *
   * @param daoFactory
   * 	dao factory. Use it to retrieve DAO
   * @return
   * 	result of operation (list, bean, etc)
   */
  public abstract R onExecute(BindDummy3DaoFactory daoFactory);

  /**
   * Use this method for operations on UI-thread after execution
   */
  public abstract void onFinish(R result);

  /**
   * Override this method to display operation progress on UI-Thread
   */
  public void onProgressUpdate(U... update) {
  }

  /**
   * Method to start operations.
   *
   * @param
   * 	data input
   */
  public void execute(@SuppressWarnings("unchecked") I... params) {
    asyncTask=new AsyncTask<I, U, R>() {
      @Override
      public void onPreExecute() {
        BindDummy3AsyncTask.this.onPreExecute();
      }

      @Override
      public R doInBackground(@SuppressWarnings("unchecked") I... params) {
        BindDummy3DataSource dataSource=BindDummy3DataSource.instance();
        R result=null;
        if (readOnlyTask) dataSource.openReadOnlyDatabase(); else dataSource.openWritableDatabase();
        try {
          result=onExecute(dataSource);
        } catch(Exception e) {
        } finally {
          if (dataSource.isOpen()) {
            dataSource.close();
          }
        }
        return result;
      }

      @Override
      public void onProgressUpdate(@SuppressWarnings("unchecked") U... values) {
        BindDummy3AsyncTask.this.onProgressUpdate(values);
      }

      @Override
      public void onPostExecute(R result) {
        BindDummy3AsyncTask.this.onFinish(result);
      }
    };
    asyncTask.execute(params);
  }

  /**
   * Simple implementation of async task. It uses read only database.
   *
   * @see BindDummy3DaoFactory
   * @see BindDummy3DataSource
   */
  public abstract static class Simple<R> extends BindDummy3AsyncTask<Void, Void, R> {
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BindBeanA_6Cursor.java:
package sqlite.foreignKey;

import android.database.Cursor;
import java.util.LinkedList;

/**
 * <p>
 * Cursor implementation for entity <code>BeanA_6</code>
 * </p>
 *  @see BeanA_6
 */
public class BindBeanA_6Cursor {
  /**
   * Cursor used to read database
   */
  protected Cursor cursor;

  /**
   * Index for column "id"
   */
  protected int index0;

  /**
   * Index for column "valueString2"
   */
  protected int index1;

  /**
   * <p>Constructor</p>
   *
   * @param cursor cursor used to read from database
   */
  BindBeanA_6Cursor(Cursor cursor) {
    wrap(cursor);
  }

  /**
   * <p>Wrap cursor with this class</p>
   *
   * @param cursor cursor to include
   */
  public BindBeanA_6Cursor wrap(Cursor cursor) {
    this.cursor=cursor;

    index0=cursor.getColumnIndex("id");
    index1=cursor.getColumnIndex("value_string2");

    return this;
  }

  /**
   * <p>Execute the cursor and read all rows from database.</p>
   *
   * @return list of beans
   */
  public LinkedList<BeanA_6> execute() {

    LinkedList<BeanA_6> resultList=new LinkedList<BeanA_6>();
    BeanA_6 resultBean=new BeanA_6();

    if (cursor.moveToFirst()) {
      do
       {
        resultBean=new BeanA_6();

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1);}

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * Method executed for each row extracted from database. For each row specified listener will be invoked.
   *
   * @param listener listener to invoke for each row
   */
  public void executeListener(OnBeanA_6Listener listener) {
    BeanA_6 resultBean=new BeanA_6();

    if (cursor.moveToFirst()) {
      do
       {
        if (index0>=0) { resultBean.id=0L;}
        if (index1>=0) { resultBean.valueString2=null;}

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1);}

        listener.onRow(resultBean, cursor.getPosition(),cursor.getCount());
      } while (cursor.moveToNext());
    }
    cursor.close();
  }

  /**
   * <p>Create a binded cursor starting from a cursor</p>
   *
   * @param cursor to wrap
   */
  public static BindBeanA_6Cursor create(Cursor cursor) {
    return new BindBeanA_6Cursor(cursor);
  }

  /**
   * <p>Listener for row read from database.</p>
   */
  public interface OnBeanA_6Listener {
    /**
     * Method executed for each row extracted from database
     *
     * @param bean loaded from database. Only selected columns/fields are valorized
     * @param rowPosition position of row
     * @param rowCount total number of rows
     */
    void onRow(BeanA_6 bean, int rowPosition, int rowCount);
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/DaoBeanA_5Impl.java:
package sqlite.foreignKey;

import android.content.ContentValues;
import android.database.Cursor;
import com.abubusoft.kripton.android.Logger;
import com.abubusoft.kripton.android.sqlite.AbstractDao;
import com.abubusoft.kripton.common.StringUtils;
import java.util.LinkedList;
import java.util.List;

/**
 * <p>
 * DAO implementation for entity <code>BeanA_5</code>, based on interface <code>DaoBeanA_5</code>
 * </p>
 *
 *  @see BeanA_5
 *  @see DaoBeanA_5
 *  @see BeanA_5Table
 */
public class DaoBeanA_5Impl extends AbstractDao implements DaoBeanA_5 {
  public DaoBeanA_5Impl(BindDummy3DataSource dataSet) {
    super(dataSet);
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE 1=1</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>bean_a2_id</dt><dd>is associated to bean's property <strong>beanA2Id</strong></dd>
   * 	<dt>value_string</dt><dd>is associated to bean's property <strong>valueString</strong></dd>
   * </dl>
   *
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_5> selectAll() {
    // build where condition
    String[] args={};

    Logger.info(StringUtils.formatSQL("SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE 1=1"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE 1=1", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_5> resultList=new LinkedList<BeanA_5>();
    BeanA_5 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("bean_a2_id");
      int index2=cursor.getColumnIndex("value_string");

      do
       {
        resultBean=new BeanA_5();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        resultBean.beanA2Id=cursor.getLong(index1);
        if (!cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE id=${id}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>bean_a2_id</dt><dd>is associated to bean's property <strong>beanA2Id</strong></dd>
   * 	<dt>value_string</dt><dd>is associated to bean's property <strong>valueString</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${id}</dt><dd>is binded to method's parameter <strong>id</strong></dd>
   * </dl>
   *
   * @param id
   * 	is binded to ${id}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_5> selectById(long id) {
    // build where condition
    String[] args={String.valueOf(id)};

    Logger.info(StringUtils.formatSQL("SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE id='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE id=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_5> resultList=new LinkedList<BeanA_5>();
    BeanA_5 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("bean_a2_id");
      int index2=cursor.getColumnIndex("value_string");

      do
       {
        resultBean=new BeanA_5();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        resultBean.beanA2Id=cursor.getLong(index1);
        if (!cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id FROM bean_a_5 WHERE valueString=${dummy}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${dummy}</dt><dd>is binded to method's parameter <strong>value</strong></dd>
   * </dl>
   *
   * @param value
   * 	is binded to ${dummy}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_5> selectByString(String value) {
    // build where condition
    String[] args={(value==null?null:value)};

    Logger.info(StringUtils.formatSQL("SELECT id FROM bean_a_5 WHERE value_string='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id FROM bean_a_5 WHERE value_string=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_5> resultList=new LinkedList<BeanA_5>();
    BeanA_5 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");

      do
       {
        resultBean=new BeanA_5();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <p>SQL insert:</p>
   * <pre>INSERT INTO bean_a_5 (bean_a2_id, value_string) VALUES (${bean.beanA2Id}, ${bean.valueString})</pre>
   *
   * <p><code>bean.id</code> is automatically updated because it is the primary key</p>
   *
   * <p><strong>Inserted columns:</strong></p>
   * <dl>
   * 	<dt>bean_a2_id</dt><dd>is mapped to <strong>${bean.beanA2Id}</strong></dd>
   * 	<dt>value_string</dt><dd>is mapped to <strong>${bean.valueString}</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is mapped to parameter <strong>bean</strong>
   *
   * @return <strong>id</strong> of inserted record
   */
  @Override
  public int insert(BeanA_5 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.beanA2Id!=null) {
      contentValues.put("bean_a2_id", bean.beanA2Id);
    } else {
      contentValues.putNull("bean_a2_id");
    }

    if (bean.valueString!=null) {
      contentValues.put("value_string", bean.valueString);
    } else {
      contentValues.putNull("value_string");
    }

    // log
    Logger.info(StringUtils.formatSQL("SQL: INSERT INTO bean_a_5 (bean_a2_id, value_string) VALUES ('"+StringUtils.checkSize(contentValues.get("bean_a2_id"))+"', '"+StringUtils.checkSize(contentValues.get("value_string"))+"')"));
    long result = database().insert("bean_a_5", null, contentValues);
    bean.id=result;

    return (int)result;
  }

  /**
   * <p>SQL Update:</p>
   * <pre>UPDATE bean_a_5 SET bean_a2_id=${bean.beanA2Id}, value_string=${bean.valueString} WHERE valueString=${bean.valueString}</pre>
   *
   * <p><strong>Updated columns:</strong></p>
   * <dl>
   * 	<dt>bean_a2_id</dt><dd>is mapped to <strong>${bean.beanA2Id}</strong></dd>
   * 	<dt>value_string</dt><dd>is mapped to <strong>${bean.valueString}</strong></dd>
   * </dl>
   *
   * <p><strong>Parameters used in where conditions:</strong></p>
   * <dl>
   * 	<dt>${bean.valueString}</dt><dd>is mapped to method's parameter <strong>bean.valueString</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is used as ${bean}
   *
   * @return number of updated records
   */
  @Override
  public int update(BeanA_5 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.beanA2Id!=null) {
      contentValues.put("bean_a2_id", bean.beanA2Id);
    } else {
      contentValues.putNull("bean_a2_id");
    }

    if (bean.valueString!=null) {
      contentValues.put("value_string", bean.valueString);
    } else {
      contentValues.putNull("value_string");
    }

    String[] whereConditions={(bean.valueString==null?null:bean.valueString)};

    Logger.info(StringUtils.formatSQL("UPDATE bean_a_5 SET bean_a2_id='"+StringUtils.checkSize(contentValues.get("bean_a2_id"))+"', value_string='"+StringUtils.checkSize(contentValues.get("value_string"))+"' WHERE valueString='%s'"), (Object[])whereConditions);
    int result = database().update("bean_a_5", contentValues, "value_string=?", whereConditions);
    return result;
  }
}


	at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:24)
	at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:20)
	at com.abubusoft.testing.compile.JavaSourcesSubject$CompilationClause.successfulCompilationResult(JavaSourcesSubject.java:310)
	at com.abubusoft.testing.compile.JavaSourcesSubject$CompilationClause.compilesWithoutError(JavaSourcesSubject.java:289)
	at base.BaseProcessorTest.buildTest(BaseProcessorTest.java:255)
	at base.BaseProcessorTest.buildDataSourceProcessorTest(BaseProcessorTest.java:231)
	at sqlite.foreignKey.TestForeignKeyCompile.testForeignKeyCompile3(TestForeignKeyCompile.java:55)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.rules.ExpectedException$ExpectedExceptionStatement.evaluate(ExpectedException.java:239)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)

Running sqlite.foreignKey.TestForeignKeySuite
Tests run: 3, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.282 sec <<< FAILURE!
testForeignKeyCompile1(sqlite.foreignKey.TestForeignKeyCompile)  Time elapsed: 0.084 sec  <<< FAILURE!
java.lang.AssertionError: Compilation produced the following errors:

error: com.abubusoft.kripton.processor.exceptions.CircularRelationshipException: Table definition bean_a_2 is in a circular dependency


Generated Files
===============

/SOURCE_OUTPUT/sqlite/foreignKey/BindDummyAsyncTask.java:
package sqlite.foreignKey;

import android.os.AsyncTask;
import java.lang.Override;
import java.lang.SuppressWarnings;

/**
 *
 * <p>
 * Specialized async task to make async database operation on activity
 * </p>
 *
 * <p>
 * Unlike standard async task, for an instance of this class can be used many time.
 * </p>
 *
 * <p>
 * When method <code>execute</code> is invoked, an inner async task is created.
 * </p>
 *
 * @see BindDummyDaoFactory
 * @see BindDummyDataSource
 */
public abstract class BindDummyAsyncTask<I, U, R> {
  /**
   * If <code>true</code> indicates database operations are only read operations
   *
   */
  protected boolean readOnlyTask;

  /**
   * Async task wrapped by this class
   *
   */
  protected AsyncTask<I, U, R> asyncTask;

  /**
   * <p>
   * With this constructor, a read only database connection will be used
   * </p>
   */
  public BindDummyAsyncTask() {
    this(true);}

  /**
   * <p>
   * With this constructor it is possible to specify which type of database use in async task
   * </p>
   *
   * @param readOnlyTask if true, force async task to use read only database connection
   */
  public BindDummyAsyncTask(boolean readOnlyTask) {
    this.readOnlyTask = readOnlyTask;}

  /**
   * Use this method for operations on UI-thread before start execution
   */
  public void onPreExecute() {
  }

  /**
   * Method used to encapsulate operations on datasource
   *
   * @param daoFactory
   * 	dao factory. Use it to retrieve DAO
   * @return
   * 	result of operation (list, bean, etc)
   */
  public abstract R onExecute(BindDummyDaoFactory daoFactory);

  /**
   * Use this method for operations on UI-thread after execution
   */
  public abstract void onFinish(R result);

  /**
   * Override this method to display operation progress on UI-Thread
   */
  public void onProgressUpdate(U... update) {
  }

  /**
   * Method to start operations.
   *
   * @param
   * 	data input
   */
  public void execute(@SuppressWarnings("unchecked") I... params) {
    asyncTask=new AsyncTask<I, U, R>() {
      @Override
      public void onPreExecute() {
        BindDummyAsyncTask.this.onPreExecute();
      }

      @Override
      public R doInBackground(@SuppressWarnings("unchecked") I... params) {
        BindDummyDataSource dataSource=BindDummyDataSource.instance();
        R result=null;
        if (readOnlyTask) dataSource.openReadOnlyDatabase(); else dataSource.openWritableDatabase();
        try {
          result=onExecute(dataSource);
        } catch(Exception e) {
        } finally {
          if (dataSource.isOpen()) {
            dataSource.close();
          }
        }
        return result;
      }

      @Override
      public void onProgressUpdate(@SuppressWarnings("unchecked") U... values) {
        BindDummyAsyncTask.this.onProgressUpdate(values);
      }

      @Override
      public void onPostExecute(R result) {
        BindDummyAsyncTask.this.onFinish(result);
      }
    };
    asyncTask.execute(params);
  }

  /**
   * Simple implementation of async task. It uses read only database.
   *
   * @see BindDummyDaoFactory
   * @see BindDummyDataSource
   */
  public abstract static class Simple<R> extends BindDummyAsyncTask<Void, Void, R> {
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_2Table.java:
package sqlite.foreignKey;

import java.lang.String;

/**
 * <p>
 * Entity <code>BeanA_2</code> is associated to table <code>bean_a_2</code>
 * This class represents table associated to entity.
 * </p>
 *  @see BeanA_2
 */
public class BeanA_2Table {
  /**
   * Costant represents name of table bean_a_2
   */
  public static final String TABLE_NAME = "bean_a_2";

  /**
   * <p>
   * DDL to create table bean_a_2
   * </p>
   *
   * <pre>CREATE TABLE bean_a_2 (pk INTEGER PRIMARY KEY AUTOINCREMENT, value_string2 TEXT);</pre>
   */
  public static final String CREATE_TABLE_SQL = "CREATE TABLE bean_a_2 (pk INTEGER PRIMARY KEY AUTOINCREMENT, value_string2 TEXT);";

  /**
   * <p>
   * DDL to drop table bean_a_2
   * </p>
   *
   * <pre>DROP TABLE IF EXISTS bean_a_2;</pre>
   */
  public static final String DROP_TABLE_SQL = "DROP TABLE IF EXISTS bean_a_2;";

  /**
   * Entity's property <code>id</code> is associated to table column <code>pk</code>. This costant represents column name.
   *
   *  @see BeanA_2#id
   */
  public static final String COLUMN_ID = "pk";

  /**
   * Entity's property <code>valueString2</code> is associated to table column <code>value_string2</code>. This costant represents column name.
   *
   *  @see BeanA_2#valueString2
   */
  public static final String COLUMN_VALUE_STRING2 = "value_string2";
}


/SOURCE_OUTPUT/sqlite/foreignKey/DaoBeanA_1Impl.java:
package sqlite.foreignKey;

import android.content.ContentValues;
import android.database.Cursor;
import com.abubusoft.kripton.android.Logger;
import com.abubusoft.kripton.android.sqlite.AbstractDao;
import com.abubusoft.kripton.common.StringUtils;
import java.util.LinkedList;
import java.util.List;

/**
 * <p>
 * DAO implementation for entity <code>BeanA_1</code>, based on interface <code>DaoBeanA_1</code>
 * </p>
 *
 *  @see BeanA_1
 *  @see DaoBeanA_1
 *  @see BeanA_1Table
 */
public class DaoBeanA_1Impl extends AbstractDao implements DaoBeanA_1 {
  public DaoBeanA_1Impl(BindDummyDataSource dataSet) {
    super(dataSet);
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE 1=1</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>bean_a2_id</dt><dd>is associated to bean's property <strong>beanA2Id</strong></dd>
   * 	<dt>value_string</dt><dd>is associated to bean's property <strong>valueString</strong></dd>
   * </dl>
   *
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_1> selectAll() {
    // build where condition
    String[] args={};

    Logger.info(StringUtils.formatSQL("SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE 1=1"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE 1=1", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_1> resultList=new LinkedList<BeanA_1>();
    BeanA_1 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("bean_a2_id");
      int index2=cursor.getColumnIndex("value_string");

      do
       {
        resultBean=new BeanA_1();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1); }
        if (!cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE id=${id}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>bean_a2_id</dt><dd>is associated to bean's property <strong>beanA2Id</strong></dd>
   * 	<dt>value_string</dt><dd>is associated to bean's property <strong>valueString</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${id}</dt><dd>is binded to method's parameter <strong>id</strong></dd>
   * </dl>
   *
   * @param id
   * 	is binded to ${id}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_1> selectById(long id) {
    // build where condition
    String[] args={String.valueOf(id)};

    Logger.info(StringUtils.formatSQL("SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE id='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, bean_a2_id, value_string FROM bean_a_1 WHERE id=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_1> resultList=new LinkedList<BeanA_1>();
    BeanA_1 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("bean_a2_id");
      int index2=cursor.getColumnIndex("value_string");

      do
       {
        resultBean=new BeanA_1();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1); }
        if (!cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id FROM bean_a_1 WHERE valueString=${dummy}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${dummy}</dt><dd>is binded to method's parameter <strong>value</strong></dd>
   * </dl>
   *
   * @param value
   * 	is binded to ${dummy}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_1> selectByString(String value) {
    // build where condition
    String[] args={(value==null?null:value)};

    Logger.info(StringUtils.formatSQL("SELECT id FROM bean_a_1 WHERE value_string='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id FROM bean_a_1 WHERE value_string=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_1> resultList=new LinkedList<BeanA_1>();
    BeanA_1 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");

      do
       {
        resultBean=new BeanA_1();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <p>SQL insert:</p>
   * <pre>INSERT INTO bean_a_1 (bean_a2_id, value_string) VALUES (${bean.beanA2Id}, ${bean.valueString})</pre>
   *
   * <p><code>bean.id</code> is automatically updated because it is the primary key</p>
   *
   * <p><strong>Inserted columns:</strong></p>
   * <dl>
   * 	<dt>bean_a2_id</dt><dd>is mapped to <strong>${bean.beanA2Id}</strong></dd>
   * 	<dt>value_string</dt><dd>is mapped to <strong>${bean.valueString}</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is mapped to parameter <strong>bean</strong>
   *
   * @return <strong>id</strong> of inserted record
   */
  @Override
  public int insert(BeanA_1 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    contentValues.put("bean_a2_id", bean.beanA2Id);

    if (bean.valueString!=null) {
      contentValues.put("value_string", bean.valueString);
    } else {
      contentValues.putNull("value_string");
    }

    // log
    Logger.info(StringUtils.formatSQL("SQL: INSERT INTO bean_a_1 (bean_a2_id, value_string) VALUES ('"+StringUtils.checkSize(contentValues.get("bean_a2_id"))+"', '"+StringUtils.checkSize(contentValues.get("value_string"))+"')"));
    long result = database().insert("bean_a_1", null, contentValues);
    bean.id=result;

    return (int)result;
  }

  /**
   * <p>SQL Update:</p>
   * <pre>UPDATE bean_a_1 SET bean_a2_id=${bean.beanA2Id}, value_string=${bean.valueString} WHERE valueString=${bean.valueString}</pre>
   *
   * <p><strong>Updated columns:</strong></p>
   * <dl>
   * 	<dt>bean_a2_id</dt><dd>is mapped to <strong>${bean.beanA2Id}</strong></dd>
   * 	<dt>value_string</dt><dd>is mapped to <strong>${bean.valueString}</strong></dd>
   * </dl>
   *
   * <p><strong>Parameters used in where conditions:</strong></p>
   * <dl>
   * 	<dt>${bean.valueString}</dt><dd>is mapped to method's parameter <strong>bean.valueString</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is used as ${bean}
   *
   * @return number of updated records
   */
  @Override
  public int update(BeanA_1 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    contentValues.put("bean_a2_id", bean.beanA2Id);

    if (bean.valueString!=null) {
      contentValues.put("value_string", bean.valueString);
    } else {
      contentValues.putNull("value_string");
    }

    String[] whereConditions={(bean.valueString==null?null:bean.valueString)};

    Logger.info(StringUtils.formatSQL("UPDATE bean_a_1 SET bean_a2_id='"+StringUtils.checkSize(contentValues.get("bean_a2_id"))+"', value_string='"+StringUtils.checkSize(contentValues.get("value_string"))+"' WHERE valueString='%s'"), (Object[])whereConditions);
    int result = database().update("bean_a_1", contentValues, "value_string=?", whereConditions);
    return result;
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BindBeanA_1Cursor.java:
package sqlite.foreignKey;

import android.database.Cursor;
import java.util.LinkedList;

/**
 * <p>
 * Cursor implementation for entity <code>BeanA_1</code>
 * </p>
 *  @see BeanA_1
 */
public class BindBeanA_1Cursor {
  /**
   * Cursor used to read database
   */
  protected Cursor cursor;

  /**
   * Index for column "id"
   */
  protected int index0;

  /**
   * Index for column "beanA2Id"
   */
  protected int index1;

  /**
   * Index for column "valueString"
   */
  protected int index2;

  /**
   * <p>Constructor</p>
   *
   * @param cursor cursor used to read from database
   */
  BindBeanA_1Cursor(Cursor cursor) {
    wrap(cursor);
  }

  /**
   * <p>Wrap cursor with this class</p>
   *
   * @param cursor cursor to include
   */
  public BindBeanA_1Cursor wrap(Cursor cursor) {
    this.cursor=cursor;

    index0=cursor.getColumnIndex("id");
    index1=cursor.getColumnIndex("bean_a2_id");
    index2=cursor.getColumnIndex("value_string");

    return this;
  }

  /**
   * <p>Execute the cursor and read all rows from database.</p>
   *
   * @return list of beans
   */
  public LinkedList<BeanA_1> execute() {

    LinkedList<BeanA_1> resultList=new LinkedList<BeanA_1>();
    BeanA_1 resultBean=new BeanA_1();

    if (cursor.moveToFirst()) {
      do
       {
        resultBean=new BeanA_1();

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1);}
        if (index2>=0 && !cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2);}

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * Method executed for each row extracted from database. For each row specified listener will be invoked.
   *
   * @param listener listener to invoke for each row
   */
  public void executeListener(OnBeanA_1Listener listener) {
    BeanA_1 resultBean=new BeanA_1();

    if (cursor.moveToFirst()) {
      do
       {
        if (index0>=0) { resultBean.id=0L;}
        if (index1>=0) { resultBean.beanA2Id=0L;}
        if (index2>=0) { resultBean.valueString=null;}

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1);}
        if (index2>=0 && !cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2);}

        listener.onRow(resultBean, cursor.getPosition(),cursor.getCount());
      } while (cursor.moveToNext());
    }
    cursor.close();
  }

  /**
   * <p>Create a binded cursor starting from a cursor</p>
   *
   * @param cursor to wrap
   */
  public static BindBeanA_1Cursor create(Cursor cursor) {
    return new BindBeanA_1Cursor(cursor);
  }

  /**
   * <p>Listener for row read from database.</p>
   */
  public interface OnBeanA_1Listener {
    /**
     * Method executed for each row extracted from database
     *
     * @param bean loaded from database. Only selected columns/fields are valorized
     * @param rowPosition position of row
     * @param rowCount total number of rows
     */
    void onRow(BeanA_1 bean, int rowPosition, int rowCount);
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_1Table.java:
package sqlite.foreignKey;

import java.lang.String;

/**
 * <p>
 * Entity <code>BeanA_1</code> is associated to table <code>bean_a_1</code>
 * This class represents table associated to entity.
 * </p>
 *  @see BeanA_1
 */
public class BeanA_1Table {
  /**
   * Costant represents name of table bean_a_1
   */
  public static final String TABLE_NAME = "bean_a_1";

  /**
   * <p>
   * DDL to create table bean_a_1
   * </p>
   *
   * <pre>CREATE TABLE bean_a_1 (id INTEGER PRIMARY KEY AUTOINCREMENT, bean_a2_id INTEGER, value_string TEXT, FOREIGN KEY(bean_a2_id) REFERENCES bean_a_2(pk));</pre>
   */
  public static final String CREATE_TABLE_SQL = "CREATE TABLE bean_a_1 (id INTEGER PRIMARY KEY AUTOINCREMENT, bean_a2_id INTEGER, value_string TEXT, FOREIGN KEY(bean_a2_id) REFERENCES bean_a_2(pk));";

  /**
   * <p>
   * DDL to drop table bean_a_1
   * </p>
   *
   * <pre>DROP TABLE IF EXISTS bean_a_1;</pre>
   */
  public static final String DROP_TABLE_SQL = "DROP TABLE IF EXISTS bean_a_1;";

  /**
   * Entity's property <code>id</code> is associated to table column <code>id</code>. This costant represents column name.
   *
   *  @see BeanA_1#id
   */
  public static final String COLUMN_ID = "id";

  /**
   * Entity's property <code>beanA2Id</code> is associated to table column <code>bean_a2_id</code>. This costant represents column name.
   *
   *  @see BeanA_1#beanA2Id
   */
  public static final String COLUMN_BEAN_A2_ID = "bean_a2_id";

  /**
   * Entity's property <code>valueString</code> is associated to table column <code>value_string</code>. This costant represents column name.
   *
   *  @see BeanA_1#valueString
   */
  public static final String COLUMN_VALUE_STRING = "value_string";
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_1BindMap.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.AbstractJacksonContext;
import com.abubusoft.kripton.AbstractMapper;
import com.abubusoft.kripton.KriptonXmlContext;
import com.abubusoft.kripton.annotation.BindMap;
import com.abubusoft.kripton.common.PrimitiveUtils;
import com.abubusoft.kripton.escape.StringEscapeUtils;
import com.abubusoft.kripton.exception.KriptonRuntimeException;
import com.abubusoft.kripton.persistence.JacksonWrapperParser;
import com.abubusoft.kripton.persistence.JacksonWrapperSerializer;
import com.abubusoft.kripton.persistence.XmlSerializer;
import com.abubusoft.kripton.persistence.XmlWrapperParser;
import com.abubusoft.kripton.persistence.XmlWrapperSerializer;
import com.abubusoft.kripton.persistence.xml.internal.XmlPullParser;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import java.lang.Exception;
import java.lang.Override;

/**
 * This class is the shared preference binder defined for BeanA_1
 *
 * @see BeanA_1
 */
@BindMap(BeanA_1.class)
public class BeanA_1BindMap extends AbstractMapper<BeanA_1> {
  /**
   * create new object instance
   */
  @Override
  public BeanA_1 createInstance() {
    return new BeanA_1();
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJackson(AbstractJacksonContext context, BeanA_1 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field beanA2Id (mapped with "beanA2Id")
      fieldCount++;
      jacksonSerializer.writeNumberField("beanA2Id", object.beanA2Id);

      // field id (mapped with "id")
      fieldCount++;
      jacksonSerializer.writeNumberField("id", object.id);

      // field valueString (mapped with "valueString")
      if (object.valueString!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString", object.valueString);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJacksonAsString(AbstractJacksonContext context, BeanA_1 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field beanA2Id (mapped with "beanA2Id")
      jacksonSerializer.writeStringField("beanA2Id", PrimitiveUtils.writeLong(object.beanA2Id));

      // field id (mapped with "id")
      jacksonSerializer.writeStringField("id", PrimitiveUtils.writeLong(object.id));

      // field valueString (mapped with "valueString")
      if (object.valueString!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString", object.valueString);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public void serializeOnXml(KriptonXmlContext context, BeanA_1 object, XmlWrapperSerializer wrapper, int currentEventType) {
    try {
      XmlSerializer xmlSerializer = wrapper.xmlSerializer;
      if (currentEventType == 0) {
        xmlSerializer.writeStartElement("beanA_1");
      }

      // Persisted fields:

      // field beanA2Id (mapped with "beanA2Id")
      xmlSerializer.writeStartElement("beanA2Id");
      xmlSerializer.writeLong(object.beanA2Id);
      xmlSerializer.writeEndElement();

      // field id (mapped with "id")
      xmlSerializer.writeStartElement("id");
      xmlSerializer.writeLong(object.id);
      xmlSerializer.writeEndElement();

      // field valueString (mapped with "valueString")
      if (object.valueString!=null) {
        xmlSerializer.writeStartElement("valueString");
        xmlSerializer.writeCharacters(StringEscapeUtils.escapeXml10(object.valueString));
        xmlSerializer.writeEndElement();
      }

      if (currentEventType == 0) {
        xmlSerializer.writeEndElement();
      }
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_1 parseOnJackson(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_1 instance = createInstance();
      String fieldName;
      if (jacksonParser.currentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.currentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "beanA2Id":
              // field beanA2Id (mapped with "beanA2Id")
              instance.beanA2Id=jacksonParser.getLongValue();
            break;
            case "id":
              // field id (mapped with "id")
              instance.id=jacksonParser.getLongValue();
            break;
            case "valueString":
              // field valueString (mapped with "valueString")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_1 parseOnJacksonAsString(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_1 instance = createInstance();
      String fieldName;
      if (jacksonParser.getCurrentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.getCurrentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "beanA2Id":
              // field beanA2Id (mapped with "beanA2Id")
              instance.beanA2Id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "id":
              // field id (mapped with "id")
              instance.id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "valueString":
              // field valueString (mapped with "valueString")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_1 parseOnXml(KriptonXmlContext context, XmlWrapperParser wrapper, int currentEventType) {
    try {
      XmlPullParser xmlParser = wrapper.xmlParser;
      BeanA_1 instance = createInstance();
      int eventType = currentEventType;
      boolean read=true;

      if (currentEventType == 0) {
        eventType = xmlParser.next();
      } else {
        eventType = xmlParser.getEventType();
      }
      String currentTag = xmlParser.getName().toString();
      String elementName = currentTag;
      // No attributes found

      //sub-elements
      while (xmlParser.hasNext() && elementName!=null) {
        if (read) {
          eventType = xmlParser.next();
        } else {
          eventType = xmlParser.getEventType();
        }
        read=true;
        switch(eventType) {
            case XmlPullParser.START_TAG:
              currentTag = xmlParser.getName().toString();
              switch(currentTag) {
                  case "beanA2Id":
                    // property beanA2Id (mapped on "beanA2Id")
                    instance.beanA2Id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "id":
                    // property id (mapped on "id")
                    instance.id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "valueString":
                    // property valueString (mapped on "valueString")
                    instance.valueString=StringEscapeUtils.unescapeXml(xmlParser.getElementText());
                  break;
                  default:
                  break;
                }
              break;
              case XmlPullParser.END_TAG:
                if (elementName.equals(xmlParser.getName())) {
                  currentTag = elementName;
                  elementName = null;
                }
              break;
              case XmlPullParser.CDSECT:
              case XmlPullParser.TEXT:
                // no property is binded to VALUE o CDATA break;
              default:
              break;
          }
        }
        return instance;
      } catch(Exception e) {
        e.printStackTrace();
        throw (new KriptonRuntimeException(e));
      }
    }
  }


/SOURCE_OUTPUT/sqlite/foreignKey/BindDummyDaoFactory.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.android.sqlite.BindDaoFactory;

/**
 * <p>
 * Represents dao factory interface for DummyDataSource.
 * This class expose database interface through Dao attribute.
 * </p>
 *
 * @see DummyDataSource
 * @see DaoBeanA_1
 * @see DaoBeanA_1Impl
 * @see BeanA_1
 * @see DaoBeanA_2
 * @see DaoBeanA_2Impl
 * @see BeanA_2
 */
public interface BindDummyDaoFactory extends BindDaoFactory {
  /**
   *
   * retrieve dao DaoBeanA_1
   */
  DaoBeanA_1Impl getDaoBeanA_1();

  /**
   *
   * retrieve dao DaoBeanA_2
   */
  DaoBeanA_2Impl getDaoBeanA_2();
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_2BindMap.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.AbstractJacksonContext;
import com.abubusoft.kripton.AbstractMapper;
import com.abubusoft.kripton.KriptonXmlContext;
import com.abubusoft.kripton.annotation.BindMap;
import com.abubusoft.kripton.common.PrimitiveUtils;
import com.abubusoft.kripton.escape.StringEscapeUtils;
import com.abubusoft.kripton.exception.KriptonRuntimeException;
import com.abubusoft.kripton.persistence.JacksonWrapperParser;
import com.abubusoft.kripton.persistence.JacksonWrapperSerializer;
import com.abubusoft.kripton.persistence.XmlSerializer;
import com.abubusoft.kripton.persistence.XmlWrapperParser;
import com.abubusoft.kripton.persistence.XmlWrapperSerializer;
import com.abubusoft.kripton.persistence.xml.internal.XmlPullParser;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import java.lang.Exception;
import java.lang.Override;

/**
 * This class is the shared preference binder defined for BeanA_2
 *
 * @see BeanA_2
 */
@BindMap(BeanA_2.class)
public class BeanA_2BindMap extends AbstractMapper<BeanA_2> {
  /**
   * create new object instance
   */
  @Override
  public BeanA_2 createInstance() {
    return new BeanA_2();
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJackson(AbstractJacksonContext context, BeanA_2 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field id (mapped with "id")
      fieldCount++;
      jacksonSerializer.writeNumberField("id", object.id);

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString2", object.valueString2);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJacksonAsString(AbstractJacksonContext context, BeanA_2 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field id (mapped with "id")
      jacksonSerializer.writeStringField("id", PrimitiveUtils.writeLong(object.id));

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString2", object.valueString2);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public void serializeOnXml(KriptonXmlContext context, BeanA_2 object, XmlWrapperSerializer wrapper, int currentEventType) {
    try {
      XmlSerializer xmlSerializer = wrapper.xmlSerializer;
      if (currentEventType == 0) {
        xmlSerializer.writeStartElement("beanA_2");
      }

      // Persisted fields:

      // field id (mapped with "id")
      xmlSerializer.writeStartElement("id");
      xmlSerializer.writeLong(object.id);
      xmlSerializer.writeEndElement();

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null) {
        xmlSerializer.writeStartElement("valueString2");
        xmlSerializer.writeCharacters(StringEscapeUtils.escapeXml10(object.valueString2));
        xmlSerializer.writeEndElement();
      }

      if (currentEventType == 0) {
        xmlSerializer.writeEndElement();
      }
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_2 parseOnJackson(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_2 instance = createInstance();
      String fieldName;
      if (jacksonParser.currentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.currentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "id":
              // field id (mapped with "id")
              instance.id=jacksonParser.getLongValue();
            break;
            case "valueString2":
              // field valueString2 (mapped with "valueString2")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString2=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_2 parseOnJacksonAsString(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_2 instance = createInstance();
      String fieldName;
      if (jacksonParser.getCurrentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.getCurrentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "id":
              // field id (mapped with "id")
              instance.id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "valueString2":
              // field valueString2 (mapped with "valueString2")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString2=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_2 parseOnXml(KriptonXmlContext context, XmlWrapperParser wrapper, int currentEventType) {
    try {
      XmlPullParser xmlParser = wrapper.xmlParser;
      BeanA_2 instance = createInstance();
      int eventType = currentEventType;
      boolean read=true;

      if (currentEventType == 0) {
        eventType = xmlParser.next();
      } else {
        eventType = xmlParser.getEventType();
      }
      String currentTag = xmlParser.getName().toString();
      String elementName = currentTag;
      // No attributes found

      //sub-elements
      while (xmlParser.hasNext() && elementName!=null) {
        if (read) {
          eventType = xmlParser.next();
        } else {
          eventType = xmlParser.getEventType();
        }
        read=true;
        switch(eventType) {
            case XmlPullParser.START_TAG:
              currentTag = xmlParser.getName().toString();
              switch(currentTag) {
                  case "id":
                    // property id (mapped on "id")
                    instance.id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "valueString2":
                    // property valueString2 (mapped on "valueString2")
                    instance.valueString2=StringEscapeUtils.unescapeXml(xmlParser.getElementText());
                  break;
                  default:
                  break;
                }
              break;
              case XmlPullParser.END_TAG:
                if (elementName.equals(xmlParser.getName())) {
                  currentTag = elementName;
                  elementName = null;
                }
              break;
              case XmlPullParser.CDSECT:
              case XmlPullParser.TEXT:
                // no property is binded to VALUE o CDATA break;
              default:
              break;
          }
        }
        return instance;
      } catch(Exception e) {
        e.printStackTrace();
        throw (new KriptonRuntimeException(e));
      }
    }
  }


/SOURCE_OUTPUT/sqlite/foreignKey/BindBeanA_2Cursor.java:
package sqlite.foreignKey;

import android.database.Cursor;
import java.util.LinkedList;

/**
 * <p>
 * Cursor implementation for entity <code>BeanA_2</code>
 * </p>
 *  @see BeanA_2
 */
public class BindBeanA_2Cursor {
  /**
   * Cursor used to read database
   */
  protected Cursor cursor;

  /**
   * Index for column "id"
   */
  protected int index0;

  /**
   * Index for column "valueString2"
   */
  protected int index1;

  /**
   * <p>Constructor</p>
   *
   * @param cursor cursor used to read from database
   */
  BindBeanA_2Cursor(Cursor cursor) {
    wrap(cursor);
  }

  /**
   * <p>Wrap cursor with this class</p>
   *
   * @param cursor cursor to include
   */
  public BindBeanA_2Cursor wrap(Cursor cursor) {
    this.cursor=cursor;

    index0=cursor.getColumnIndex("id");
    index1=cursor.getColumnIndex("value_string2");

    return this;
  }

  /**
   * <p>Execute the cursor and read all rows from database.</p>
   *
   * @return list of beans
   */
  public LinkedList<BeanA_2> execute() {

    LinkedList<BeanA_2> resultList=new LinkedList<BeanA_2>();
    BeanA_2 resultBean=new BeanA_2();

    if (cursor.moveToFirst()) {
      do
       {
        resultBean=new BeanA_2();

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1);}

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * Method executed for each row extracted from database. For each row specified listener will be invoked.
   *
   * @param listener listener to invoke for each row
   */
  public void executeListener(OnBeanA_2Listener listener) {
    BeanA_2 resultBean=new BeanA_2();

    if (cursor.moveToFirst()) {
      do
       {
        if (index0>=0) { resultBean.id=0L;}
        if (index1>=0) { resultBean.valueString2=null;}

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1);}

        listener.onRow(resultBean, cursor.getPosition(),cursor.getCount());
      } while (cursor.moveToNext());
    }
    cursor.close();
  }

  /**
   * <p>Create a binded cursor starting from a cursor</p>
   *
   * @param cursor to wrap
   */
  public static BindBeanA_2Cursor create(Cursor cursor) {
    return new BindBeanA_2Cursor(cursor);
  }

  /**
   * <p>Listener for row read from database.</p>
   */
  public interface OnBeanA_2Listener {
    /**
     * Method executed for each row extracted from database
     *
     * @param bean loaded from database. Only selected columns/fields are valorized
     * @param rowPosition position of row
     * @param rowCount total number of rows
     */
    void onRow(BeanA_2 bean, int rowPosition, int rowCount);
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/DaoBeanA_2Impl.java:
package sqlite.foreignKey;

import android.content.ContentValues;
import android.database.Cursor;
import com.abubusoft.kripton.android.Logger;
import com.abubusoft.kripton.android.sqlite.AbstractDao;
import com.abubusoft.kripton.common.StringUtils;
import java.util.LinkedList;
import java.util.List;

/**
 * <p>
 * DAO implementation for entity <code>BeanA_2</code>, based on interface <code>DaoBeanA_2</code>
 * </p>
 *
 *  @see BeanA_2
 *  @see DaoBeanA_2
 *  @see BeanA_2Table
 */
public class DaoBeanA_2Impl extends AbstractDao implements DaoBeanA_2 {
  public DaoBeanA_2Impl(BindDummyDataSource dataSet) {
    super(dataSet);
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, value_string2 FROM bean_a_2 WHERE 1=1</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>value_string2</dt><dd>is associated to bean's property <strong>valueString2</strong></dd>
   * </dl>
   *
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_2> selectAll() {
    // build where condition
    String[] args={};

    Logger.info(StringUtils.formatSQL("SELECT id, value_string2 FROM bean_a_2 WHERE 1=1"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, value_string2 FROM bean_a_2 WHERE 1=1", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_2> resultList=new LinkedList<BeanA_2>();
    BeanA_2 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("value_string2");

      do
       {
        resultBean=new BeanA_2();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, value_string2 FROM bean_a_2 WHERE id=${id}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>value_string2</dt><dd>is associated to bean's property <strong>valueString2</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${id}</dt><dd>is binded to method's parameter <strong>id</strong></dd>
   * </dl>
   *
   * @param id
   * 	is binded to ${id}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_2> selectById(long id) {
    // build where condition
    String[] args={String.valueOf(id)};

    Logger.info(StringUtils.formatSQL("SELECT id, value_string2 FROM bean_a_2 WHERE id='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, value_string2 FROM bean_a_2 WHERE id=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_2> resultList=new LinkedList<BeanA_2>();
    BeanA_2 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("value_string2");

      do
       {
        resultBean=new BeanA_2();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id FROM bean_a_2 WHERE valueString2=${dummy}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${dummy}</dt><dd>is binded to method's parameter <strong>value</strong></dd>
   * </dl>
   *
   * @param value
   * 	is binded to ${dummy}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_2> selectByString(String value) {
    // build where condition
    String[] args={(value==null?null:value)};

    Logger.info(StringUtils.formatSQL("SELECT id FROM bean_a_2 WHERE value_string2='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id FROM bean_a_2 WHERE value_string2=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_2> resultList=new LinkedList<BeanA_2>();
    BeanA_2 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");

      do
       {
        resultBean=new BeanA_2();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <p>SQL insert:</p>
   * <pre>INSERT INTO bean_a_2 (value_string2) VALUES (${bean.valueString2})</pre>
   *
   * <p><code>bean.id</code> is automatically updated because it is the primary key</p>
   *
   * <p><strong>Inserted columns:</strong></p>
   * <dl>
   * 	<dt>value_string2</dt><dd>is mapped to <strong>${bean.valueString2}</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is mapped to parameter <strong>bean</strong>
   *
   * @return <strong>id</strong> of inserted record
   */
  @Override
  public int insert(BeanA_2 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.valueString2!=null) {
      contentValues.put("value_string2", bean.valueString2);
    } else {
      contentValues.putNull("value_string2");
    }

    // log
    Logger.info(StringUtils.formatSQL("SQL: INSERT INTO bean_a_2 (value_string2) VALUES ('"+StringUtils.checkSize(contentValues.get("value_string2"))+"')"));
    long result = database().insert("bean_a_2", null, contentValues);
    bean.id=result;

    return (int)result;
  }

  /**
   * <p>SQL Update:</p>
   * <pre>UPDATE bean_a_2 SET value_string2=${bean.valueString2} WHERE valueString2=${bean.valueString2}</pre>
   *
   * <p><strong>Updated columns:</strong></p>
   * <dl>
   * 	<dt>value_string2</dt><dd>is mapped to <strong>${bean.valueString2}</strong></dd>
   * </dl>
   *
   * <p><strong>Parameters used in where conditions:</strong></p>
   * <dl>
   * 	<dt>${bean.valueString2}</dt><dd>is mapped to method's parameter <strong>bean.valueString2</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is used as ${bean}
   *
   * @return number of updated records
   */
  @Override
  public int update(BeanA_2 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.valueString2!=null) {
      contentValues.put("value_string2", bean.valueString2);
    } else {
      contentValues.putNull("value_string2");
    }

    String[] whereConditions={(bean.valueString2==null?null:bean.valueString2)};

    Logger.info(StringUtils.formatSQL("UPDATE bean_a_2 SET value_string2='"+StringUtils.checkSize(contentValues.get("value_string2"))+"' WHERE valueString2='%s'"), (Object[])whereConditions);
    int result = database().update("bean_a_2", contentValues, "value_string2=?", whereConditions);
    return result;
  }
}


	at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:24)
	at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:20)
	at com.abubusoft.testing.compile.JavaSourcesSubject$CompilationClause.successfulCompilationResult(JavaSourcesSubject.java:310)
	at com.abubusoft.testing.compile.JavaSourcesSubject$CompilationClause.compilesWithoutError(JavaSourcesSubject.java:289)
	at base.BaseProcessorTest.buildTest(BaseProcessorTest.java:255)
	at base.BaseProcessorTest.buildDataSourceProcessorTest(BaseProcessorTest.java:231)
	at sqlite.foreignKey.TestForeignKeyCompile.testForeignKeyCompile1(TestForeignKeyCompile.java:44)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.rules.ExpectedException$ExpectedExceptionStatement.evaluate(ExpectedException.java:239)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runners.Suite.runChild(Suite.java:128)
	at org.junit.runners.Suite.runChild(Suite.java:27)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)

testForeignKeyCompile3(sqlite.foreignKey.TestForeignKeyCompile)  Time elapsed: 0.096 sec  <<< FAILURE!
java.lang.AssertionError: Compilation produced the following errors:

error: com.abubusoft.kripton.processor.exceptions.CircularRelationshipException: Table definition bean_a_6 is in a circular dependency


Generated Files
===============

/SOURCE_OUTPUT/sqlite/foreignKey/BindBeanA_5Cursor.java:
package sqlite.foreignKey;

import android.database.Cursor;
import java.util.LinkedList;

/**
 * <p>
 * Cursor implementation for entity <code>BeanA_5</code>
 * </p>
 *  @see BeanA_5
 */
public class BindBeanA_5Cursor {
  /**
   * Cursor used to read database
   */
  protected Cursor cursor;

  /**
   * Index for column "id"
   */
  protected int index0;

  /**
   * Index for column "beanA2Id"
   */
  protected int index1;

  /**
   * Index for column "valueString"
   */
  protected int index2;

  /**
   * <p>Constructor</p>
   *
   * @param cursor cursor used to read from database
   */
  BindBeanA_5Cursor(Cursor cursor) {
    wrap(cursor);
  }

  /**
   * <p>Wrap cursor with this class</p>
   *
   * @param cursor cursor to include
   */
  public BindBeanA_5Cursor wrap(Cursor cursor) {
    this.cursor=cursor;

    index0=cursor.getColumnIndex("id");
    index1=cursor.getColumnIndex("bean_a2_id");
    index2=cursor.getColumnIndex("value_string");

    return this;
  }

  /**
   * <p>Execute the cursor and read all rows from database.</p>
   *
   * @return list of beans
   */
  public LinkedList<BeanA_5> execute() {

    LinkedList<BeanA_5> resultList=new LinkedList<BeanA_5>();
    BeanA_5 resultBean=new BeanA_5();

    if (cursor.moveToFirst()) {
      do
       {
        resultBean=new BeanA_5();

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1);}
        if (index2>=0 && !cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2);}

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * Method executed for each row extracted from database. For each row specified listener will be invoked.
   *
   * @param listener listener to invoke for each row
   */
  public void executeListener(OnBeanA_5Listener listener) {
    BeanA_5 resultBean=new BeanA_5();

    if (cursor.moveToFirst()) {
      do
       {
        if (index0>=0) { resultBean.id=0L;}
        if (index1>=0) { resultBean.beanA2Id=null;}
        if (index2>=0) { resultBean.valueString=null;}

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.beanA2Id=cursor.getLong(index1);}
        if (index2>=0 && !cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2);}

        listener.onRow(resultBean, cursor.getPosition(),cursor.getCount());
      } while (cursor.moveToNext());
    }
    cursor.close();
  }

  /**
   * <p>Create a binded cursor starting from a cursor</p>
   *
   * @param cursor to wrap
   */
  public static BindBeanA_5Cursor create(Cursor cursor) {
    return new BindBeanA_5Cursor(cursor);
  }

  /**
   * <p>Listener for row read from database.</p>
   */
  public interface OnBeanA_5Listener {
    /**
     * Method executed for each row extracted from database
     *
     * @param bean loaded from database. Only selected columns/fields are valorized
     * @param rowPosition position of row
     * @param rowCount total number of rows
     */
    void onRow(BeanA_5 bean, int rowPosition, int rowCount);
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/DaoBeanA_6Impl.java:
package sqlite.foreignKey;

import android.content.ContentValues;
import android.database.Cursor;
import com.abubusoft.kripton.android.Logger;
import com.abubusoft.kripton.android.sqlite.AbstractDao;
import com.abubusoft.kripton.common.StringUtils;
import java.util.LinkedList;
import java.util.List;

/**
 * <p>
 * DAO implementation for entity <code>BeanA_6</code>, based on interface <code>DaoBeanA_6</code>
 * </p>
 *
 *  @see BeanA_6
 *  @see DaoBeanA_6
 *  @see BeanA_6Table
 */
public class DaoBeanA_6Impl extends AbstractDao implements DaoBeanA_6 {
  public DaoBeanA_6Impl(BindDummy3DataSource dataSet) {
    super(dataSet);
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, value_string2 FROM bean_a_6 WHERE 1=1</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>value_string2</dt><dd>is associated to bean's property <strong>valueString2</strong></dd>
   * </dl>
   *
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_6> selectAll() {
    // build where condition
    String[] args={};

    Logger.info(StringUtils.formatSQL("SELECT id, value_string2 FROM bean_a_6 WHERE 1=1"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, value_string2 FROM bean_a_6 WHERE 1=1", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_6> resultList=new LinkedList<BeanA_6>();
    BeanA_6 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("value_string2");

      do
       {
        resultBean=new BeanA_6();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, value_string2 FROM bean_a_6 WHERE id=${id}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>value_string2</dt><dd>is associated to bean's property <strong>valueString2</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${id}</dt><dd>is binded to method's parameter <strong>id</strong></dd>
   * </dl>
   *
   * @param id
   * 	is binded to ${id}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_6> selectById(long id) {
    // build where condition
    String[] args={String.valueOf(id)};

    Logger.info(StringUtils.formatSQL("SELECT id, value_string2 FROM bean_a_6 WHERE id='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, value_string2 FROM bean_a_6 WHERE id=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_6> resultList=new LinkedList<BeanA_6>();
    BeanA_6 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("value_string2");

      do
       {
        resultBean=new BeanA_6();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        if (!cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id FROM bean_a_6 WHERE valueString2=${dummy}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${dummy}</dt><dd>is binded to method's parameter <strong>value</strong></dd>
   * </dl>
   *
   * @param value
   * 	is binded to ${dummy}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_6> selectByString(String value) {
    // build where condition
    String[] args={(value==null?null:value)};

    Logger.info(StringUtils.formatSQL("SELECT id FROM bean_a_6 WHERE value_string2='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id FROM bean_a_6 WHERE value_string2=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_6> resultList=new LinkedList<BeanA_6>();
    BeanA_6 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");

      do
       {
        resultBean=new BeanA_6();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <p>SQL insert:</p>
   * <pre>INSERT INTO bean_a_6 (value_string2) VALUES (${bean.valueString2})</pre>
   *
   * <p><code>bean.id</code> is automatically updated because it is the primary key</p>
   *
   * <p><strong>Inserted columns:</strong></p>
   * <dl>
   * 	<dt>value_string2</dt><dd>is mapped to <strong>${bean.valueString2}</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is mapped to parameter <strong>bean</strong>
   *
   * @return <strong>id</strong> of inserted record
   */
  @Override
  public int insert(BeanA_6 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.valueString2!=null) {
      contentValues.put("value_string2", bean.valueString2);
    } else {
      contentValues.putNull("value_string2");
    }

    // log
    Logger.info(StringUtils.formatSQL("SQL: INSERT INTO bean_a_6 (value_string2) VALUES ('"+StringUtils.checkSize(contentValues.get("value_string2"))+"')"));
    long result = database().insert("bean_a_6", null, contentValues);
    bean.id=result;

    return (int)result;
  }

  /**
   * <p>SQL Update:</p>
   * <pre>UPDATE bean_a_6 SET value_string2=${bean.valueString2} WHERE valueString2=${bean.valueString2}</pre>
   *
   * <p><strong>Updated columns:</strong></p>
   * <dl>
   * 	<dt>value_string2</dt><dd>is mapped to <strong>${bean.valueString2}</strong></dd>
   * </dl>
   *
   * <p><strong>Parameters used in where conditions:</strong></p>
   * <dl>
   * 	<dt>${bean.valueString2}</dt><dd>is mapped to method's parameter <strong>bean.valueString2</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is used as ${bean}
   *
   * @return number of updated records
   */
  @Override
  public int update(BeanA_6 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.valueString2!=null) {
      contentValues.put("value_string2", bean.valueString2);
    } else {
      contentValues.putNull("value_string2");
    }

    String[] whereConditions={(bean.valueString2==null?null:bean.valueString2)};

    Logger.info(StringUtils.formatSQL("UPDATE bean_a_6 SET value_string2='"+StringUtils.checkSize(contentValues.get("value_string2"))+"' WHERE valueString2='%s'"), (Object[])whereConditions);
    int result = database().update("bean_a_6", contentValues, "value_string2=?", whereConditions);
    return result;
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_5BindMap.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.AbstractJacksonContext;
import com.abubusoft.kripton.AbstractMapper;
import com.abubusoft.kripton.KriptonXmlContext;
import com.abubusoft.kripton.annotation.BindMap;
import com.abubusoft.kripton.common.PrimitiveUtils;
import com.abubusoft.kripton.escape.StringEscapeUtils;
import com.abubusoft.kripton.exception.KriptonRuntimeException;
import com.abubusoft.kripton.persistence.JacksonWrapperParser;
import com.abubusoft.kripton.persistence.JacksonWrapperSerializer;
import com.abubusoft.kripton.persistence.XmlSerializer;
import com.abubusoft.kripton.persistence.XmlWrapperParser;
import com.abubusoft.kripton.persistence.XmlWrapperSerializer;
import com.abubusoft.kripton.persistence.xml.internal.XmlPullParser;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import java.lang.Exception;
import java.lang.Override;

/**
 * This class is the shared preference binder defined for BeanA_5
 *
 * @see BeanA_5
 */
@BindMap(BeanA_5.class)
public class BeanA_5BindMap extends AbstractMapper<BeanA_5> {
  /**
   * create new object instance
   */
  @Override
  public BeanA_5 createInstance() {
    return new BeanA_5();
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJackson(AbstractJacksonContext context, BeanA_5 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field beanA2Id (mapped with "beanA2Id")
      if (object.beanA2Id!=null)  {
        fieldCount++;
        jacksonSerializer.writeNumberField("beanA2Id", object.beanA2Id);
      }

      // field id (mapped with "id")
      fieldCount++;
      jacksonSerializer.writeNumberField("id", object.id);

      // field valueString (mapped with "valueString")
      if (object.valueString!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString", object.valueString);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJacksonAsString(AbstractJacksonContext context, BeanA_5 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field beanA2Id (mapped with "beanA2Id")
      if (object.beanA2Id!=null)  {
        jacksonSerializer.writeStringField("beanA2Id", PrimitiveUtils.writeLong(object.beanA2Id));
      }

      // field id (mapped with "id")
      jacksonSerializer.writeStringField("id", PrimitiveUtils.writeLong(object.id));

      // field valueString (mapped with "valueString")
      if (object.valueString!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString", object.valueString);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public void serializeOnXml(KriptonXmlContext context, BeanA_5 object, XmlWrapperSerializer wrapper, int currentEventType) {
    try {
      XmlSerializer xmlSerializer = wrapper.xmlSerializer;
      if (currentEventType == 0) {
        xmlSerializer.writeStartElement("beanA_5");
      }

      // Persisted fields:

      // field beanA2Id (mapped with "beanA2Id")
      if (object.beanA2Id!=null)  {
        xmlSerializer.writeStartElement("beanA2Id");
        xmlSerializer.writeLong(object.beanA2Id);
        xmlSerializer.writeEndElement();
      }

      // field id (mapped with "id")
      xmlSerializer.writeStartElement("id");
      xmlSerializer.writeLong(object.id);
      xmlSerializer.writeEndElement();

      // field valueString (mapped with "valueString")
      if (object.valueString!=null) {
        xmlSerializer.writeStartElement("valueString");
        xmlSerializer.writeCharacters(StringEscapeUtils.escapeXml10(object.valueString));
        xmlSerializer.writeEndElement();
      }

      if (currentEventType == 0) {
        xmlSerializer.writeEndElement();
      }
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_5 parseOnJackson(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_5 instance = createInstance();
      String fieldName;
      if (jacksonParser.currentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.currentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "beanA2Id":
              // field beanA2Id (mapped with "beanA2Id")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.beanA2Id=jacksonParser.getLongValue();
              }
            break;
            case "id":
              // field id (mapped with "id")
              instance.id=jacksonParser.getLongValue();
            break;
            case "valueString":
              // field valueString (mapped with "valueString")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_5 parseOnJacksonAsString(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_5 instance = createInstance();
      String fieldName;
      if (jacksonParser.getCurrentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.getCurrentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "beanA2Id":
              // field beanA2Id (mapped with "beanA2Id")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.beanA2Id=PrimitiveUtils.readLong(jacksonParser.getText(), null);
              }
            break;
            case "id":
              // field id (mapped with "id")
              instance.id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "valueString":
              // field valueString (mapped with "valueString")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_5 parseOnXml(KriptonXmlContext context, XmlWrapperParser wrapper, int currentEventType) {
    try {
      XmlPullParser xmlParser = wrapper.xmlParser;
      BeanA_5 instance = createInstance();
      int eventType = currentEventType;
      boolean read=true;

      if (currentEventType == 0) {
        eventType = xmlParser.next();
      } else {
        eventType = xmlParser.getEventType();
      }
      String currentTag = xmlParser.getName().toString();
      String elementName = currentTag;
      // No attributes found

      //sub-elements
      while (xmlParser.hasNext() && elementName!=null) {
        if (read) {
          eventType = xmlParser.next();
        } else {
          eventType = xmlParser.getEventType();
        }
        read=true;
        switch(eventType) {
            case XmlPullParser.START_TAG:
              currentTag = xmlParser.getName().toString();
              switch(currentTag) {
                  case "beanA2Id":
                    // property beanA2Id (mapped on "beanA2Id")
                    instance.beanA2Id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), null);
                  break;
                  case "id":
                    // property id (mapped on "id")
                    instance.id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "valueString":
                    // property valueString (mapped on "valueString")
                    instance.valueString=StringEscapeUtils.unescapeXml(xmlParser.getElementText());
                  break;
                  default:
                  break;
                }
              break;
              case XmlPullParser.END_TAG:
                if (elementName.equals(xmlParser.getName())) {
                  currentTag = elementName;
                  elementName = null;
                }
              break;
              case XmlPullParser.CDSECT:
              case XmlPullParser.TEXT:
                // no property is binded to VALUE o CDATA break;
              default:
              break;
          }
        }
        return instance;
      } catch(Exception e) {
        e.printStackTrace();
        throw (new KriptonRuntimeException(e));
      }
    }
  }


/SOURCE_OUTPUT/sqlite/foreignKey/BindDummy3DaoFactory.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.android.sqlite.BindDaoFactory;

/**
 * <p>
 * Represents dao factory interface for Dummy3DataSource.
 * This class expose database interface through Dao attribute.
 * </p>
 *
 * @see Dummy3DataSource
 * @see DaoBeanA_5
 * @see DaoBeanA_5Impl
 * @see BeanA_5
 * @see DaoBeanA_6
 * @see DaoBeanA_6Impl
 * @see BeanA_6
 */
public interface BindDummy3DaoFactory extends BindDaoFactory {
  /**
   *
   * retrieve dao DaoBeanA_5
   */
  DaoBeanA_5Impl getDaoBeanA_5();

  /**
   *
   * retrieve dao DaoBeanA_6
   */
  DaoBeanA_6Impl getDaoBeanA_6();
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_6BindMap.java:
package sqlite.foreignKey;

import com.abubusoft.kripton.AbstractJacksonContext;
import com.abubusoft.kripton.AbstractMapper;
import com.abubusoft.kripton.KriptonXmlContext;
import com.abubusoft.kripton.annotation.BindMap;
import com.abubusoft.kripton.common.PrimitiveUtils;
import com.abubusoft.kripton.escape.StringEscapeUtils;
import com.abubusoft.kripton.exception.KriptonRuntimeException;
import com.abubusoft.kripton.persistence.JacksonWrapperParser;
import com.abubusoft.kripton.persistence.JacksonWrapperSerializer;
import com.abubusoft.kripton.persistence.XmlSerializer;
import com.abubusoft.kripton.persistence.XmlWrapperParser;
import com.abubusoft.kripton.persistence.XmlWrapperSerializer;
import com.abubusoft.kripton.persistence.xml.internal.XmlPullParser;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import java.lang.Exception;
import java.lang.Override;

/**
 * This class is the shared preference binder defined for BeanA_6
 *
 * @see BeanA_6
 */
@BindMap(BeanA_6.class)
public class BeanA_6BindMap extends AbstractMapper<BeanA_6> {
  /**
   * create new object instance
   */
  @Override
  public BeanA_6 createInstance() {
    return new BeanA_6();
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJackson(AbstractJacksonContext context, BeanA_6 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field id (mapped with "id")
      fieldCount++;
      jacksonSerializer.writeNumberField("id", object.id);

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString2", object.valueString2);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public int serializeOnJacksonAsString(AbstractJacksonContext context, BeanA_6 object, JacksonWrapperSerializer wrapper) {
    try {
      JsonGenerator jacksonSerializer = wrapper.jacksonGenerator;
      jacksonSerializer.writeStartObject();
      int fieldCount=0;

      // Serialized Field:

      // field id (mapped with "id")
      jacksonSerializer.writeStringField("id", PrimitiveUtils.writeLong(object.id));

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null)  {
        fieldCount++;
        jacksonSerializer.writeStringField("valueString2", object.valueString2);
      }

      jacksonSerializer.writeEndObject();
      return fieldCount;
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * reset shared preferences
   */
  @Override
  public void serializeOnXml(KriptonXmlContext context, BeanA_6 object, XmlWrapperSerializer wrapper, int currentEventType) {
    try {
      XmlSerializer xmlSerializer = wrapper.xmlSerializer;
      if (currentEventType == 0) {
        xmlSerializer.writeStartElement("beanA_6");
      }

      // Persisted fields:

      // field id (mapped with "id")
      xmlSerializer.writeStartElement("id");
      xmlSerializer.writeLong(object.id);
      xmlSerializer.writeEndElement();

      // field valueString2 (mapped with "valueString2")
      if (object.valueString2!=null) {
        xmlSerializer.writeStartElement("valueString2");
        xmlSerializer.writeCharacters(StringEscapeUtils.escapeXml10(object.valueString2));
        xmlSerializer.writeEndElement();
      }

      if (currentEventType == 0) {
        xmlSerializer.writeEndElement();
      }
    } catch(Exception e) {
      e.printStackTrace();
      throw (new KriptonRuntimeException(e));
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_6 parseOnJackson(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_6 instance = createInstance();
      String fieldName;
      if (jacksonParser.currentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.currentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "id":
              // field id (mapped with "id")
              instance.id=jacksonParser.getLongValue();
            break;
            case "valueString2":
              // field valueString2 (mapped with "valueString2")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString2=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_6 parseOnJacksonAsString(AbstractJacksonContext context, JacksonWrapperParser wrapper) {
    try {
      JsonParser jacksonParser = wrapper.jacksonParser;
      BeanA_6 instance = createInstance();
      String fieldName;
      if (jacksonParser.getCurrentToken() == null) {
        jacksonParser.nextToken();
      }
      if (jacksonParser.getCurrentToken() != JsonToken.START_OBJECT) {
        jacksonParser.skipChildren();
        return instance;
      }
      while (jacksonParser.nextToken() != JsonToken.END_OBJECT) {
        fieldName = jacksonParser.getCurrentName();
        jacksonParser.nextToken();

        // Parse fields:
        switch (fieldName) {
            case "id":
              // field id (mapped with "id")
              instance.id=PrimitiveUtils.readLong(jacksonParser.getText(), 0L);
            break;
            case "valueString2":
              // field valueString2 (mapped with "valueString2")
              if (jacksonParser.currentToken()!=JsonToken.VALUE_NULL) {
                instance.valueString2=jacksonParser.getText();
              }
            break;
            default:
              jacksonParser.skipChildren();
            break;}
      }
      return instance;
    } catch (Exception e) {
      e.printStackTrace();
      throw new KriptonRuntimeException(e);
    }
  }

  /**
   * create new object instance
   */
  @Override
  public BeanA_6 parseOnXml(KriptonXmlContext context, XmlWrapperParser wrapper, int currentEventType) {
    try {
      XmlPullParser xmlParser = wrapper.xmlParser;
      BeanA_6 instance = createInstance();
      int eventType = currentEventType;
      boolean read=true;

      if (currentEventType == 0) {
        eventType = xmlParser.next();
      } else {
        eventType = xmlParser.getEventType();
      }
      String currentTag = xmlParser.getName().toString();
      String elementName = currentTag;
      // No attributes found

      //sub-elements
      while (xmlParser.hasNext() && elementName!=null) {
        if (read) {
          eventType = xmlParser.next();
        } else {
          eventType = xmlParser.getEventType();
        }
        read=true;
        switch(eventType) {
            case XmlPullParser.START_TAG:
              currentTag = xmlParser.getName().toString();
              switch(currentTag) {
                  case "id":
                    // property id (mapped on "id")
                    instance.id=PrimitiveUtils.readLong(xmlParser.getElementAsLong(), 0L);
                  break;
                  case "valueString2":
                    // property valueString2 (mapped on "valueString2")
                    instance.valueString2=StringEscapeUtils.unescapeXml(xmlParser.getElementText());
                  break;
                  default:
                  break;
                }
              break;
              case XmlPullParser.END_TAG:
                if (elementName.equals(xmlParser.getName())) {
                  currentTag = elementName;
                  elementName = null;
                }
              break;
              case XmlPullParser.CDSECT:
              case XmlPullParser.TEXT:
                // no property is binded to VALUE o CDATA break;
              default:
              break;
          }
        }
        return instance;
      } catch(Exception e) {
        e.printStackTrace();
        throw (new KriptonRuntimeException(e));
      }
    }
  }


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_5Table.java:
package sqlite.foreignKey;

import java.lang.String;

/**
 * <p>
 * Entity <code>BeanA_5</code> is associated to table <code>bean_a_5</code>
 * This class represents table associated to entity.
 * </p>
 *  @see BeanA_5
 */
public class BeanA_5Table {
  /**
   * Costant represents name of table bean_a_5
   */
  public static final String TABLE_NAME = "bean_a_5";

  /**
   * <p>
   * DDL to create table bean_a_5
   * </p>
   *
   * <pre>CREATE TABLE bean_a_5 (id INTEGER PRIMARY KEY AUTOINCREMENT, bean_a2_id INTEGER NOT NULL, value_string TEXT, FOREIGN KEY(bean_a2_id) REFERENCES bean_a_6(pk));</pre>
   */
  public static final String CREATE_TABLE_SQL = "CREATE TABLE bean_a_5 (id INTEGER PRIMARY KEY AUTOINCREMENT, bean_a2_id INTEGER NOT NULL, value_string TEXT, FOREIGN KEY(bean_a2_id) REFERENCES bean_a_6(pk));";

  /**
   * <p>
   * DDL to drop table bean_a_5
   * </p>
   *
   * <pre>DROP TABLE IF EXISTS bean_a_5;</pre>
   */
  public static final String DROP_TABLE_SQL = "DROP TABLE IF EXISTS bean_a_5;";

  /**
   * Entity's property <code>id</code> is associated to table column <code>id</code>. This costant represents column name.
   *
   *  @see BeanA_5#id
   */
  public static final String COLUMN_ID = "id";

  /**
   * Entity's property <code>beanA2Id</code> is associated to table column <code>bean_a2_id</code>. This costant represents column name.
   *
   *  @see BeanA_5#beanA2Id
   */
  public static final String COLUMN_BEAN_A2_ID = "bean_a2_id";

  /**
   * Entity's property <code>valueString</code> is associated to table column <code>value_string</code>. This costant represents column name.
   *
   *  @see BeanA_5#valueString
   */
  public static final String COLUMN_VALUE_STRING = "value_string";
}


/SOURCE_OUTPUT/sqlite/foreignKey/BeanA_6Table.java:
package sqlite.foreignKey;

import java.lang.String;

/**
 * <p>
 * Entity <code>BeanA_6</code> is associated to table <code>bean_a_6</code>
 * This class represents table associated to entity.
 * </p>
 *  @see BeanA_6
 */
public class BeanA_6Table {
  /**
   * Costant represents name of table bean_a_6
   */
  public static final String TABLE_NAME = "bean_a_6";

  /**
   * <p>
   * DDL to create table bean_a_6
   * </p>
   *
   * <pre>CREATE TABLE bean_a_6 (pk INTEGER PRIMARY KEY AUTOINCREMENT, value_string2 TEXT);</pre>
   */
  public static final String CREATE_TABLE_SQL = "CREATE TABLE bean_a_6 (pk INTEGER PRIMARY KEY AUTOINCREMENT, value_string2 TEXT);";

  /**
   * <p>
   * DDL to drop table bean_a_6
   * </p>
   *
   * <pre>DROP TABLE IF EXISTS bean_a_6;</pre>
   */
  public static final String DROP_TABLE_SQL = "DROP TABLE IF EXISTS bean_a_6;";

  /**
   * Entity's property <code>id</code> is associated to table column <code>pk</code>. This costant represents column name.
   *
   *  @see BeanA_6#id
   */
  public static final String COLUMN_ID = "pk";

  /**
   * Entity's property <code>valueString2</code> is associated to table column <code>value_string2</code>. This costant represents column name.
   *
   *  @see BeanA_6#valueString2
   */
  public static final String COLUMN_VALUE_STRING2 = "value_string2";
}


/SOURCE_OUTPUT/sqlite/foreignKey/BindDummy3AsyncTask.java:
package sqlite.foreignKey;

import android.os.AsyncTask;
import java.lang.Override;
import java.lang.SuppressWarnings;

/**
 *
 * <p>
 * Specialized async task to make async database operation on activity
 * </p>
 *
 * <p>
 * Unlike standard async task, for an instance of this class can be used many time.
 * </p>
 *
 * <p>
 * When method <code>execute</code> is invoked, an inner async task is created.
 * </p>
 *
 * @see BindDummy3DaoFactory
 * @see BindDummy3DataSource
 */
public abstract class BindDummy3AsyncTask<I, U, R> {
  /**
   * If <code>true</code> indicates database operations are only read operations
   *
   */
  protected boolean readOnlyTask;

  /**
   * Async task wrapped by this class
   *
   */
  protected AsyncTask<I, U, R> asyncTask;

  /**
   * <p>
   * With this constructor, a read only database connection will be used
   * </p>
   */
  public BindDummy3AsyncTask() {
    this(true);}

  /**
   * <p>
   * With this constructor it is possible to specify which type of database use in async task
   * </p>
   *
   * @param readOnlyTask if true, force async task to use read only database connection
   */
  public BindDummy3AsyncTask(boolean readOnlyTask) {
    this.readOnlyTask = readOnlyTask;}

  /**
   * Use this method for operations on UI-thread before start execution
   */
  public void onPreExecute() {
  }

  /**
   * Method used to encapsulate operations on datasource
   *
   * @param daoFactory
   * 	dao factory. Use it to retrieve DAO
   * @return
   * 	result of operation (list, bean, etc)
   */
  public abstract R onExecute(BindDummy3DaoFactory daoFactory);

  /**
   * Use this method for operations on UI-thread after execution
   */
  public abstract void onFinish(R result);

  /**
   * Override this method to display operation progress on UI-Thread
   */
  public void onProgressUpdate(U... update) {
  }

  /**
   * Method to start operations.
   *
   * @param
   * 	data input
   */
  public void execute(@SuppressWarnings("unchecked") I... params) {
    asyncTask=new AsyncTask<I, U, R>() {
      @Override
      public void onPreExecute() {
        BindDummy3AsyncTask.this.onPreExecute();
      }

      @Override
      public R doInBackground(@SuppressWarnings("unchecked") I... params) {
        BindDummy3DataSource dataSource=BindDummy3DataSource.instance();
        R result=null;
        if (readOnlyTask) dataSource.openReadOnlyDatabase(); else dataSource.openWritableDatabase();
        try {
          result=onExecute(dataSource);
        } catch(Exception e) {
        } finally {
          if (dataSource.isOpen()) {
            dataSource.close();
          }
        }
        return result;
      }

      @Override
      public void onProgressUpdate(@SuppressWarnings("unchecked") U... values) {
        BindDummy3AsyncTask.this.onProgressUpdate(values);
      }

      @Override
      public void onPostExecute(R result) {
        BindDummy3AsyncTask.this.onFinish(result);
      }
    };
    asyncTask.execute(params);
  }

  /**
   * Simple implementation of async task. It uses read only database.
   *
   * @see BindDummy3DaoFactory
   * @see BindDummy3DataSource
   */
  public abstract static class Simple<R> extends BindDummy3AsyncTask<Void, Void, R> {
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/BindBeanA_6Cursor.java:
package sqlite.foreignKey;

import android.database.Cursor;
import java.util.LinkedList;

/**
 * <p>
 * Cursor implementation for entity <code>BeanA_6</code>
 * </p>
 *  @see BeanA_6
 */
public class BindBeanA_6Cursor {
  /**
   * Cursor used to read database
   */
  protected Cursor cursor;

  /**
   * Index for column "id"
   */
  protected int index0;

  /**
   * Index for column "valueString2"
   */
  protected int index1;

  /**
   * <p>Constructor</p>
   *
   * @param cursor cursor used to read from database
   */
  BindBeanA_6Cursor(Cursor cursor) {
    wrap(cursor);
  }

  /**
   * <p>Wrap cursor with this class</p>
   *
   * @param cursor cursor to include
   */
  public BindBeanA_6Cursor wrap(Cursor cursor) {
    this.cursor=cursor;

    index0=cursor.getColumnIndex("id");
    index1=cursor.getColumnIndex("value_string2");

    return this;
  }

  /**
   * <p>Execute the cursor and read all rows from database.</p>
   *
   * @return list of beans
   */
  public LinkedList<BeanA_6> execute() {

    LinkedList<BeanA_6> resultList=new LinkedList<BeanA_6>();
    BeanA_6 resultBean=new BeanA_6();

    if (cursor.moveToFirst()) {
      do
       {
        resultBean=new BeanA_6();

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1);}

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * Method executed for each row extracted from database. For each row specified listener will be invoked.
   *
   * @param listener listener to invoke for each row
   */
  public void executeListener(OnBeanA_6Listener listener) {
    BeanA_6 resultBean=new BeanA_6();

    if (cursor.moveToFirst()) {
      do
       {
        if (index0>=0) { resultBean.id=0L;}
        if (index1>=0) { resultBean.valueString2=null;}

        if (index0>=0 && !cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0);}
        if (index1>=0 && !cursor.isNull(index1)) { resultBean.valueString2=cursor.getString(index1);}

        listener.onRow(resultBean, cursor.getPosition(),cursor.getCount());
      } while (cursor.moveToNext());
    }
    cursor.close();
  }

  /**
   * <p>Create a binded cursor starting from a cursor</p>
   *
   * @param cursor to wrap
   */
  public static BindBeanA_6Cursor create(Cursor cursor) {
    return new BindBeanA_6Cursor(cursor);
  }

  /**
   * <p>Listener for row read from database.</p>
   */
  public interface OnBeanA_6Listener {
    /**
     * Method executed for each row extracted from database
     *
     * @param bean loaded from database. Only selected columns/fields are valorized
     * @param rowPosition position of row
     * @param rowCount total number of rows
     */
    void onRow(BeanA_6 bean, int rowPosition, int rowCount);
  }
}


/SOURCE_OUTPUT/sqlite/foreignKey/DaoBeanA_5Impl.java:
package sqlite.foreignKey;

import android.content.ContentValues;
import android.database.Cursor;
import com.abubusoft.kripton.android.Logger;
import com.abubusoft.kripton.android.sqlite.AbstractDao;
import com.abubusoft.kripton.common.StringUtils;
import java.util.LinkedList;
import java.util.List;

/**
 * <p>
 * DAO implementation for entity <code>BeanA_5</code>, based on interface <code>DaoBeanA_5</code>
 * </p>
 *
 *  @see BeanA_5
 *  @see DaoBeanA_5
 *  @see BeanA_5Table
 */
public class DaoBeanA_5Impl extends AbstractDao implements DaoBeanA_5 {
  public DaoBeanA_5Impl(BindDummy3DataSource dataSet) {
    super(dataSet);
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE 1=1</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>bean_a2_id</dt><dd>is associated to bean's property <strong>beanA2Id</strong></dd>
   * 	<dt>value_string</dt><dd>is associated to bean's property <strong>valueString</strong></dd>
   * </dl>
   *
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_5> selectAll() {
    // build where condition
    String[] args={};

    Logger.info(StringUtils.formatSQL("SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE 1=1"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE 1=1", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_5> resultList=new LinkedList<BeanA_5>();
    BeanA_5 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("bean_a2_id");
      int index2=cursor.getColumnIndex("value_string");

      do
       {
        resultBean=new BeanA_5();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        resultBean.beanA2Id=cursor.getLong(index1);
        if (!cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE id=${id}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * 	<dt>bean_a2_id</dt><dd>is associated to bean's property <strong>beanA2Id</strong></dd>
   * 	<dt>value_string</dt><dd>is associated to bean's property <strong>valueString</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${id}</dt><dd>is binded to method's parameter <strong>id</strong></dd>
   * </dl>
   *
   * @param id
   * 	is binded to ${id}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_5> selectById(long id) {
    // build where condition
    String[] args={String.valueOf(id)};

    Logger.info(StringUtils.formatSQL("SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE id='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id, bean_a2_id, value_string FROM bean_a_5 WHERE id=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_5> resultList=new LinkedList<BeanA_5>();
    BeanA_5 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");
      int index1=cursor.getColumnIndex("bean_a2_id");
      int index2=cursor.getColumnIndex("value_string");

      do
       {
        resultBean=new BeanA_5();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }
        resultBean.beanA2Id=cursor.getLong(index1);
        if (!cursor.isNull(index2)) { resultBean.valueString=cursor.getString(index2); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <h2>Select SQL:</h2>
   * <p>
   * <pre>SELECT id FROM bean_a_5 WHERE valueString=${dummy}</pre>
   *
   * <h2>Projected columns:</h2>
   * <p>
   * <dl>
   * 	<dt>id</dt><dd>is associated to bean's property <strong>id</strong></dd>
   * </dl>
   *
   * <h2>Query's parameters:</h2>
   * <p>
   * <dl>
   * 	<dt>${dummy}</dt><dd>is binded to method's parameter <strong>value</strong></dd>
   * </dl>
   *
   * @param value
   * 	is binded to ${dummy}
   *
   * @return collection of bean or empty collection.
   */
  @Override
  public List<BeanA_5> selectByString(String value) {
    // build where condition
    String[] args={(value==null?null:value)};

    Logger.info(StringUtils.formatSQL("SELECT id FROM bean_a_5 WHERE value_string='%s'"),(Object[])args);
    Cursor cursor = database().rawQuery("SELECT id FROM bean_a_5 WHERE value_string=?", args);
    Logger.info("Rows found: %s",cursor.getCount());

    LinkedList<BeanA_5> resultList=new LinkedList<BeanA_5>();
    BeanA_5 resultBean=null;

    if (cursor.moveToFirst()) {

      int index0=cursor.getColumnIndex("id");

      do
       {
        resultBean=new BeanA_5();

        if (!cursor.isNull(index0)) { resultBean.id=cursor.getLong(index0); }

        resultList.add(resultBean);
      } while (cursor.moveToNext());
    }
    cursor.close();

    return resultList;
  }

  /**
   * <p>SQL insert:</p>
   * <pre>INSERT INTO bean_a_5 (bean_a2_id, value_string) VALUES (${bean.beanA2Id}, ${bean.valueString})</pre>
   *
   * <p><code>bean.id</code> is automatically updated because it is the primary key</p>
   *
   * <p><strong>Inserted columns:</strong></p>
   * <dl>
   * 	<dt>bean_a2_id</dt><dd>is mapped to <strong>${bean.beanA2Id}</strong></dd>
   * 	<dt>value_string</dt><dd>is mapped to <strong>${bean.valueString}</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is mapped to parameter <strong>bean</strong>
   *
   * @return <strong>id</strong> of inserted record
   */
  @Override
  public int insert(BeanA_5 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.beanA2Id!=null) {
      contentValues.put("bean_a2_id", bean.beanA2Id);
    } else {
      contentValues.putNull("bean_a2_id");
    }

    if (bean.valueString!=null) {
      contentValues.put("value_string", bean.valueString);
    } else {
      contentValues.putNull("value_string");
    }

    // log
    Logger.info(StringUtils.formatSQL("SQL: INSERT INTO bean_a_5 (bean_a2_id, value_string) VALUES ('"+StringUtils.checkSize(contentValues.get("bean_a2_id"))+"', '"+StringUtils.checkSize(contentValues.get("value_string"))+"')"));
    long result = database().insert("bean_a_5", null, contentValues);
    bean.id=result;

    return (int)result;
  }

  /**
   * <p>SQL Update:</p>
   * <pre>UPDATE bean_a_5 SET bean_a2_id=${bean.beanA2Id}, value_string=${bean.valueString} WHERE valueString=${bean.valueString}</pre>
   *
   * <p><strong>Updated columns:</strong></p>
   * <dl>
   * 	<dt>bean_a2_id</dt><dd>is mapped to <strong>${bean.beanA2Id}</strong></dd>
   * 	<dt>value_string</dt><dd>is mapped to <strong>${bean.valueString}</strong></dd>
   * </dl>
   *
   * <p><strong>Parameters used in where conditions:</strong></p>
   * <dl>
   * 	<dt>${bean.valueString}</dt><dd>is mapped to method's parameter <strong>bean.valueString</strong></dd>
   * </dl>
   *
   * @param bean
   * 	is used as ${bean}
   *
   * @return number of updated records
   */
  @Override
  public int update(BeanA_5 bean) {
    ContentValues contentValues=contentValues();
    contentValues.clear();

    if (bean.beanA2Id!=null) {
      contentValues.put("bean_a2_id", bean.beanA2Id);
    } else {
      contentValues.putNull("bean_a2_id");
    }

    if (bean.valueString!=null) {
      contentValues.put("value_string", bean.valueString);
    } else {
      contentValues.putNull("value_string");
    }

    String[] whereConditions={(bean.valueString==null?null:bean.valueString)};

    Logger.info(StringUtils.formatSQL("UPDATE bean_a_5 SET bean_a2_id='"+StringUtils.checkSize(contentValues.get("bean_a2_id"))+"', value_string='"+StringUtils.checkSize(contentValues.get("value_string"))+"' WHERE valueString='%s'"), (Object[])whereConditions);
    int result = database().update("bean_a_5", contentValues, "value_string=?", whereConditions);
    return result;
  }
}


	at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:24)
	at com.google.common.truth.FailureStrategy.fail(FailureStrategy.java:20)
	at com.abubusoft.testing.compile.JavaSourcesSubject$CompilationClause.successfulCompilationResult(JavaSourcesSubject.java:310)
	at com.abubusoft.testing.compile.JavaSourcesSubject$CompilationClause.compilesWithoutError(JavaSourcesSubject.java:289)
	at base.BaseProcessorTest.buildTest(BaseProcessorTest.java:255)
	at base.BaseProcessorTest.buildDataSourceProcessorTest(BaseProcessorTest.java:231)
	at sqlite.foreignKey.TestForeignKeyCompile.testForeignKeyCompile3(TestForeignKeyCompile.java:55)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.rules.ExpectedException$ExpectedExceptionStatement.evaluate(ExpectedException.java:239)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runners.Suite.runChild(Suite.java:128)
	at org.junit.runners.Suite.runChild(Suite.java:27)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)

Running sqlite.kripton33.Test33Compile
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.429 sec
Running sqlite.kripton33.Test33Suite
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.432 sec
Running sqlite.kripton38.Test38Compile
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.406 sec
Running sqlite.kripton38.Test38Suite
Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.064 sec
Running sqlite.kripton40.Test40Compile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.207 sec
Running sqlite.kripton40.Test40Suite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.203 sec
Running sqlite.kripton41.Test41Compile
Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.941 sec
Running sqlite.kripton41.Test41Suite
Tests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.042 sec
Running sqlite.kripton48.Test48Compile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.241 sec
Running sqlite.kripton48.Test48Suite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.2 sec
Running sqlite.kripton49.Test49Compile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.216 sec
Running sqlite.kripton49.Test49Suite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.252 sec
Running sqlite.kripton51.Test51Compile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.225 sec
Running sqlite.kripton51.Test51Suite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.184 sec
Running sqlite.kripton56.Test56Compile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.192 sec
Running sqlite.kripton56.Test56Suite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.197 sec
Running sqlite.kripton58.Test58Array2Compile
Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.873 sec
Running sqlite.kripton58.Test58ArrayCompile
Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.001 sec
Running sqlite.kripton58.Test58ListCompile
Tests run: 9, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.123 sec
Running sqlite.kripton58.Test58Suite
Tests run: 27, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.047 sec
Running sqlite.kripton60.Test60Compile
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.363 sec
Running sqlite.kripton60.Test60Suite
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.268 sec
Running sqlite.kripton62.Test62Compile
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.942 sec
Running sqlite.kripton62.Test62Suite
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.874 sec
Running sqlite.kripton63.Test63Compile
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.35 sec
Running sqlite.kripton63.Test63Suite
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.365 sec
Running sqlite.kripton64.Test64ACompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.308 sec
Running sqlite.kripton64.Test64BCompile
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.297 sec
Running sqlite.kripton64.Test64Compile
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.999 sec
Running sqlite.kripton64.Test64Suite
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.681 sec
Running sqlite.kripton84.Test84A
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.393 sec
Running sqlite.kripton84.Test84B
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.342 sec
Running sqlite.kripton84.Test84Suite
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.633 sec
Running sqlite.test01.Test01Suite
Tests run: 13, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.828 sec
Running sqlite.test01.TestDatabase01
Tests run: 13, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.843 sec
Running sqlite.test02.Test02Suite
Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.381 sec
Running sqlite.test02.TestDao01
Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.281 sec
Running sqlite.test03.Test03
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.356 sec
Running sqlite.test03.Test03Suite
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.348 sec
Running sqlite.test05firt_aid.Test05Suite
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.164 sec
Running sqlite.test05firt_aid.TestFirstAid
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.165 sec

Results :

Failed tests:   testForeignKeyCompile1(sqlite.foreignKey.TestForeignKeyCompile): Compilation produced the following errors:(..)
  testForeignKeyCompile3(sqlite.foreignKey.TestForeignKeyCompile): Compilation produced the following errors:(..)
  testForeignKeyCompile1(sqlite.foreignKey.TestForeignKeyCompile): Compilation produced the following errors:(..)
  testForeignKeyCompile3(sqlite.foreignKey.TestForeignKeyCompile): Compilation produced the following errors:(..)

Tests run: 297, Failures: 4, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 01:05 min
[INFO] Finished at: 2016-12-26T18:58:50+01:00
[INFO] Final Memory: 28M/349M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.12.4:test (default-test) on project kripton-processor: There are test failures.
[ERROR] 
[ERROR] Please refer to C:\Users\xcesco\git\kripton\KriptonProcessor\target\surefire-reports for the individual test results.
[ERROR] -> [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
