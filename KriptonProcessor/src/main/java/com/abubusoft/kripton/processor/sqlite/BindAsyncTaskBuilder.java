package com.abubusoft.kripton.processor.sqlite;

import java.io.IOException;
import java.util.Date;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.PackageElement;
import javax.lang.model.util.Elements;

import android.database.sqlite.SQLiteDatabase;
import android.os.AsyncTask;

import com.abubusoft.kripton.processor.core.reflect.TypeUtility;
import com.abubusoft.kripton.processor.sqlite.model.SQLiteDatabaseSchema;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;
import com.squareup.javapoet.TypeVariableName;

/**
 * Utility class to generate async task for database operations
 */
public class BindAsyncTaskBuilder {

	public static final String PREFIX = "Bind";

	public static final String SUFFIX = "AsyncTask";

	private static Builder builder;

	/**
	 * Generate async task for database operations
	 * 
	 * @throws IOException
	 */
	public static void generate(Elements elementUtils, Filer filer, SQLiteDatabaseSchema schema) throws IOException {
		String className = schema.getName();

		String dataSourceName = PREFIX + className;

		className = className.replaceAll(BindDataSourceBuilder.SUFFIX, SUFFIX);
		className = PREFIX + className;

		PackageElement pkg = elementUtils.getPackageOf(schema.getElement());
		String packageName = pkg.isUnnamed() ? null : pkg.getQualifiedName().toString();

		//@formatter:off
		builder = TypeSpec.classBuilder(className).addModifiers(Modifier.PUBLIC).addModifiers(Modifier.ABSTRACT)
				.addTypeVariable(TypeVariableName.get("I"))
				.addTypeVariable(TypeVariableName.get("U"))
				.addTypeVariable(TypeVariableName.get("R"));
		//@formatter:on

		// javadoc
		builder.addJavadoc("Generated by Kripton Library.\n\n@since $L\n\n", (new Date()).toString());

		// build constructors
		builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).addCode("this(true);").build());
		builder.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).addParameter(Boolean.TYPE, "readOnlyTask").addCode("this.readOnlyTask = readOnlyTask;").build());

		// define fields
		{
			FieldSpec.Builder fieldSpec = FieldSpec.builder(Boolean.TYPE, "readOnlyTask", Modifier.PROTECTED);
			fieldSpec.addJavadoc("If <code>true</code> indicates database operations are only read operations\n\n");
			builder.addField(fieldSpec.build());
		}

		{
			ParameterizedTypeName parameterizedTypeName = ParameterizedTypeName.get(TypeUtility.className(AsyncTask.class), TypeUtility.typeName("I"), TypeUtility.typeName("U"), TypeUtility.typeName("R"));
			FieldSpec.Builder fieldSpec = FieldSpec.builder(parameterizedTypeName, "asyncTask", Modifier.PROTECTED);
			fieldSpec.addJavadoc("Async task wrapped by this class\n\n");
			builder.addField(fieldSpec.build());
		}

		// build methods
		builder.addMethod(MethodSpec.methodBuilder("onPreExecute").addModifiers(Modifier.PUBLIC).addJavadoc("Use this method for operations on UI-thread before start execution\n").build());
		
		builder.addMethod(MethodSpec.methodBuilder("onExecute")
				.returns(TypeUtility.typeName("R"))
				.addParameter(TypeUtility.typeName(className.replaceAll(SUFFIX, BindDaoFactoryBuilder.SUFFIX)), "daoFactory")				
				.addJavadoc("Method used to encapsulate operations on datasource\n\n@param daoFactory\n\tdao factory. Use it to retrieve DAO\n@return\n\tresult of operation (list, bean, etc)\n")
				.addModifiers(Modifier.PUBLIC)
				.addModifiers(Modifier.ABSTRACT).build());
		builder.addMethod(MethodSpec.methodBuilder("onFinish").addParameter(TypeUtility.typeName("R"), "result").addModifiers(Modifier.PUBLIC).addModifiers(Modifier.ABSTRACT).addJavadoc("Use this method for operations on UI-thread after execution\n").build());
		
		builder.addMethod(MethodSpec.methodBuilder("onProgressUpdate")
				.addModifiers(Modifier.PUBLIC)				
				.addParameter(TypeUtility.typeName("R"), "result")
				.addJavadoc("Override this method to display operation progress on UI-Thred\n")
				.build());

		MethodSpec.Builder executeBuilder = MethodSpec.methodBuilder("execute")				
				.addParameter(ParameterSpec.builder(ArrayTypeName.of(TypeUtility.className("I")), "params").build()).varargs(true)
				.addModifiers(Modifier.PUBLIC)
				.addJavadoc("Method to start operations.\n\n@param\n\tdata input\n");

		//@formatter:off
		TypeSpec.Builder anonymous = TypeSpec.anonymousClassBuilder("").addSuperinterface(ParameterizedTypeName.get(TypeUtility.className(AsyncTask.class), TypeUtility.className("I"), TypeUtility.className("U"), TypeUtility.className("R")));
		anonymous.addMethod(MethodSpec.methodBuilder("onPreExecute").addModifiers(Modifier.PUBLIC).addAnnotation(Override.class).addStatement("$L.this.onPreExecute()",className).build());
		anonymous.addMethod(MethodSpec.methodBuilder("doInBackground").addModifiers(Modifier.PUBLIC).returns(TypeUtility.typeName("R")).addAnnotation(Override.class)
				.addParameter(ParameterSpec.builder(ArrayTypeName.of(TypeUtility.className("I")), "params").build()).varargs(true)
				.addStatement("R result=null")
				.addStatement("$L dataSource=$L.instance()", dataSourceName, dataSourceName)
				.addStatement("$T sqlite=readOnlyTask ? dataSource.getReadableDatabase() : dataSource.getWritableDatabase()", SQLiteDatabase.class)
				.beginControlFlow("try")
				.addStatement("result=onExecute(dataSource)")
				.nextControlFlow("catch(Exception e)")
				.nextControlFlow("finally")
					.beginControlFlow("if (sqlite!=null && sqlite.isOpen())")
					.addStatement("sqlite.close()")
					.endControlFlow()
				.endControlFlow()
				.addStatement("return null").build());
		anonymous.addMethod(MethodSpec.methodBuilder("onProgressUpdate")
				.addModifiers(Modifier.PUBLIC)
				.addAnnotation(Override.class)
				.addParameter(ParameterSpec.builder(ArrayTypeName.of(TypeUtility.className("U")), "values").build())
				.varargs(true)
				.addStatement("onProgressUpdate(values)")
				.build());
		
		anonymous.addMethod(MethodSpec.methodBuilder("onPostExecute")
				.addModifiers(Modifier.PUBLIC)
				.addAnnotation(Override.class)
				.addParameter(ParameterSpec.builder(TypeUtility.className("R"), "result").build())
				.addStatement("$L.this.onFinish(result)",className)
				.build());
		//@formatter:on

		//@formatter:off
		executeBuilder.addStatement("asyncTask=$L", anonymous.build());
		executeBuilder.addStatement("asyncTask.execute(params)", anonymous.build());
		builder.addMethod(executeBuilder.build());
					
		anonymous.addMethod(MethodSpec.methodBuilder("cancel")
				.addModifiers(Modifier.PUBLIC)
				.addModifiers(Modifier.FINAL)
				.addParameter(Boolean.TYPE, "mayInterruptIfRunning")
				.beginControlFlow("if (asyncTask!=null, args)")
				.addStatement("return asyncTask.cancel(mayInterruptIfRunning)")
				.endControlFlow()
				.addStatement("return false").build());

		
		// build BasicAsyncTask
		builder.addType(TypeSpec.classBuilder("Simple")
				.addJavadoc("Simple implementation of asynctask. Used to only read from database and use data when finish to read from datasource\n")
				.addModifiers(Modifier.PUBLIC)
				.addModifiers(Modifier.STATIC)
				.addModifiers(Modifier.ABSTRACT)
				.addTypeVariable(TypeVariableName.get("R"))
				.superclass(
						ParameterizedTypeName.get(TypeUtility.className(className),
								TypeUtility.className("Void"), 
								TypeUtility.className("Void"), 
								TypeUtility.className("R")
								)							
				).build());		
		//@formatter:on

		TypeSpec typeSpec = builder.build();
		JavaFile.builder(packageName, typeSpec).build().writeTo(filer);
	}

}
