package com.abubusoft.kripton.processor.sqlite;

import static com.abubusoft.kripton.processor.core.reflect.TypeUtility.typeName;

import java.util.Date;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.PackageElement;
import javax.lang.model.util.Elements;

import com.abubusoft.kripton.android.annotation.BindDelete;
import com.abubusoft.kripton.android.annotation.BindDeleteBean;
import com.abubusoft.kripton.android.annotation.BindInsert;
import com.abubusoft.kripton.android.annotation.BindInsertBean;
import com.abubusoft.kripton.android.annotation.BindSelect;
import com.abubusoft.kripton.android.annotation.BindSelectBean;
import com.abubusoft.kripton.android.annotation.BindUpdate;
import com.abubusoft.kripton.android.annotation.BuindUpdateBean;
import com.abubusoft.kripton.android.sqlite.AbstractBindDao;
import com.abubusoft.kripton.processor.BindDatabaseProcessor;
import com.abubusoft.kripton.processor.core.reflect.TypeUtility;
import com.abubusoft.kripton.processor.sqlite.exceptions.MethodWithoutSupportedAnnotationException;
import com.abubusoft.kripton.processor.sqlite.model.SQLDaoDefinition;
import com.abubusoft.kripton.processor.sqlite.model.SQLEntity;
import com.abubusoft.kripton.processor.sqlite.model.SQLiteDatabaseSchema;
import com.abubusoft.kripton.processor.sqlite.model.SQLiteModelElementVisitor;
import com.abubusoft.kripton.processor.sqlite.model.SQLiteModelMethod;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;

/**
 * Dao generator
 * 
 * @author xcesco
 *
 */
public class BindDaoGenerator implements SQLiteModelElementVisitor {

	public static final String PREFIX = "Bind";
	protected Elements elementUtils;
	protected Filer filer;
	private Builder builder;
	private SQLDaoDefinition currentDaoDefinition;
	private SQLiteDatabaseSchema model;

	public BindDaoGenerator(SQLiteDatabaseSchema model, Elements elementUtils, Filer filer) {
		this.model = model;
		this.elementUtils = elementUtils;
		this.filer = filer;
	}

	public static void generate(Elements elementUtils, Filer filer, SQLiteDatabaseSchema model) throws Exception {
		BindDaoGenerator visitor = new BindDaoGenerator(model, elementUtils, filer);

		for (SQLDaoDefinition item : model.getCollection()) {
			item.accept(visitor);
		}
	}

	@Override
	public void visit(SQLDaoDefinition value) throws Exception {
		currentDaoDefinition = value;

		String classTableName = value.getName();
		classTableName = PREFIX + classTableName;

		PackageElement pkg = elementUtils.getPackageOf(value.getElement());
		String packageName = pkg.isUnnamed() ? null : pkg.getQualifiedName().toString();

		builder = TypeSpec.classBuilder(classTableName).superclass(AbstractBindDao.class).addSuperinterface(typeName(value.getElement())).addModifiers(Modifier.PUBLIC);
		// builder.addAnnotation(AnnotationSpec.builder(SQLDaoImplementation.class).addMember("schema", CodeBlock.of("$T", model.getElement().asType())).build());
		// generiamo il javadoc contenente la data di generazione della classe
		builder.addJavadoc("Generated by Kripton Library.\n\n @since $L\n\n", (new Date()).toString());
		// builder.addMethod(buildCreateMethod(definition, elementUtils));

		// add database field
		// FieldSpec fieldDatabase = FieldSpec.builder(SQLiteDatabase.class, "database", Modifier.PROTECTED).build();// .initializer("\"$L\"", classNameConverter.convert(value.getName())).build();
		// builder.addField(fieldDatabase);

		// add content value field
		// FieldSpec fieldContentValues = FieldSpec.builder(ContentValues.class, "contentValues", Modifier.PROTECTED).initializer("new ContentValues()").build();
		// builder.addField(fieldContentValues);

		//generateExecuteListener(model.getEntity(currentDaoDefinition.getEntityClassName()));
		
		// define column name set
		for (SQLiteModelMethod item : value.getCollection()) {
			item.accept(this);
		}

		TypeSpec typeSpec = builder.build();
		BindDatabaseProcessor.info("WRITE " + typeSpec.name);
		JavaFile.builder(packageName, typeSpec).build().writeTo(filer);
	}

	@Override
	public void visit(SQLiteModelMethod value) throws Exception {

		if (value.getAnnotation(BindInsert.class) != null) {
			SQLiteInsertBuilder.generate(elementUtils, builder, model, currentDaoDefinition, value);
		} else if (value.getAnnotation(BindInsertBean.class) != null) {
			SQLiteInsertBeanBuilder.generate(elementUtils, builder, model, currentDaoDefinition, value);
		} else if (value.getAnnotation(BindUpdate.class) != null) {
			SQLiteUpdateBuilder.generate(elementUtils, builder, model, currentDaoDefinition, value);
		} else if (value.getAnnotation(BuindUpdateBean.class) != null) {
			SQLiteUpdateBeanBuilder.generate(elementUtils, builder, model, currentDaoDefinition, value);
		} else if (value.getAnnotation(BindDelete.class) != null) {
			SQLiteDeleteBuilder.generate(elementUtils, builder, model, currentDaoDefinition, value);
		} else if (value.getAnnotation(BindDeleteBean.class) != null) {
			SQLiteDeleteBeanBuilder.generate(elementUtils, builder, model, currentDaoDefinition, value);
		} else if (value.getAnnotation(BindSelect.class) != null) {
			SQLiteSelectBuilder.generate(elementUtils, builder, model, currentDaoDefinition, value);
		} else if (value.getAnnotation(BindSelectBean.class) != null) {
			SQLiteSelectBeanBuilder.generate(elementUtils, builder, model, currentDaoDefinition, value);
		} else {
			// method without supported annotation
			throw (new MethodWithoutSupportedAnnotationException(currentDaoDefinition, value));
		}

	}
	
	private MethodSpec.Builder generateExecuteListener(SQLEntity entity) {		
		String interfaceName="On" + entity.getSimpleName() + "Listener";
		Builder listenerInterface = TypeSpec.interfaceBuilder(interfaceName).addModifiers(Modifier.PUBLIC);
		listenerInterface.addMethod(MethodSpec.methodBuilder("onRow").addParameter(ParameterSpec.builder(typeName(entity.getElement()), "bean").build()).addParameter(ParameterSpec.builder(Integer.TYPE, "rowPosition").build()).addParameter(ParameterSpec.builder(Integer.TYPE, "rowCount").build())
				.returns(Void.TYPE).addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT).build());
		ClassName interfaceType=TypeUtility.className("", interfaceName);
		
		
		// javadoc for interface
		listenerInterface.addJavadoc("Listener for row read from database.\n\n");
		listenerInterface.addJavadoc("@param bean bean read from database. Only selected columns/fields are valorized.\n");
		listenerInterface.addJavadoc("@param rowPosition position of row.\n");
		listenerInterface.addJavadoc("@param rowCount total number of rows.\n");
		listenerInterface.addJavadoc("\n");
		
		TypeSpec listenerClass = listenerInterface.build();		
		builder.addType(listenerClass);
		
		MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("executeListener").addModifiers(Modifier.PUBLIC).addParameter(ParameterSpec.builder(interfaceType, "listener").build()).returns(TypeName.VOID);
		//MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("executeListener").returns(TypeName.VOID);		
		
		return methodBuilder;
	}

}
