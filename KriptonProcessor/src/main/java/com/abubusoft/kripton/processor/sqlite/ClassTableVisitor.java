package com.abubusoft.kripton.processor.sqlite;

import java.util.Date;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.PackageElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;

import com.abubusoft.kripton.common.CaseFormat;
import com.abubusoft.kripton.common.Converter;
import com.abubusoft.kripton.processor.core.KriptonAnalyzer;
import com.abubusoft.kripton.processor.core.KriptonClass;
import com.abubusoft.kripton.processor.core.KriptonElementVisitor;
import com.abubusoft.kripton.processor.core.KriptonProperty;
import com.abubusoft.kripton.processor.core.KriptonType;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;

/**
 * Classe usata per generare le tabelle
 * 
 * @author xcesco
 *
 */
public class ClassTableVisitor implements KriptonElementVisitor {

	public static final String SUFFIX = "Table";
	protected Elements elementUtils;
	protected Filer filer;
	private Builder builder;

	private TypeMirror STRING;
	private TypeMirror INTEGER;
	private Converter<String, String> columnNameConverter;
	private Converter<String, String> columnValueConverter;

	public ClassTableVisitor(Elements elementUtils, Filer filer) {
		this.elementUtils = elementUtils;
		this.filer = filer;

		STRING = elementUtils.getTypeElement(String.class.getCanonicalName()).asType();
		INTEGER = elementUtils.getTypeElement(Integer.class.getCanonicalName()).asType();
	}

	@Override
	public void visit(KriptonAnalyzer kriptonAnalyzer) throws Exception {
		for (KriptonClass item : kriptonAnalyzer.getCollection()) {
			visit(item);
		}

	}

	@Override
	public void visit(KriptonClass kriptonClass) throws Exception {
		String classTableName = kriptonClass.getName() + SUFFIX;

		PackageElement pkg = elementUtils.getPackageOf(kriptonClass.getElement());
		String packageName = pkg.isUnnamed() ? null : pkg.getQualifiedName().toString();

		builder = TypeSpec.classBuilder(classTableName).addModifiers(Modifier.PUBLIC);
		// generiamo il javadoc contenente la data di generazione della classe
		builder.addJavadoc("Generated by Kripton Library.\n\n @since $L\n\n", (new Date()).toString());
		// builder.addMethod(buildCreateMethod(definition, elementUtils));

		Converter<String, String> classNameConverter = CaseFormat.UPPER_CAMEL.converterTo(CaseFormat.LOWER_UNDERSCORE);
		columnNameConverter = CaseFormat.UPPER_CAMEL.converterTo(CaseFormat.UPPER_UNDERSCORE);
		columnValueConverter = CaseFormat.UPPER_CAMEL.converterTo(CaseFormat.LOWER_UNDERSCORE);
		
		// com.squareup.javapoet.FieldSpec.Builder fieldTable = FieldSpec.builder(String.class, "TABLE_NAME", Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
		// JavaFile.builder(packageName, typeSpec).build().writeTo(filer);
		FieldSpec fieldSpec = FieldSpec.builder(String.class, "TABLE_NAME", Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL).initializer("\"$L\"", classNameConverter.convert(kriptonClass.getName())).build();
		
		builder.addField(fieldSpec);

		// define column name set
		for (KriptonProperty item : kriptonClass.getCollection()) {
			item.accept(this);
		}

		TypeSpec typeSpec = builder.build();

		JavaFile.builder(packageName, typeSpec).build().writeTo(filer);
	}

	@Override
	public void visit(KriptonProperty kriptonProperty) {
		FieldSpec fieldSpec = FieldSpec.builder(String.class, "COLUMN_"+columnNameConverter.convert(kriptonProperty.getName()), Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL).initializer("\"$L\"", columnValueConverter.convert(kriptonProperty.getName())).build();
		
		builder.addField(fieldSpec);
	}

	@Override
	public void visit(KriptonType kriptonType) {

	}

}
